<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>Harmony</title>
		<meta charset="utf-8"/>
		<meta name="description" content="Procedural Drawing Tool"/>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
		<style type="text/css">
			*
			{
				color: #444;
				font-family: Monospace;
				font-size: 12px;
			}

			body
			{
				margin: 0px;
				overflow: hidden;
			}

			select
			{
				text-transform: uppercase;
				font-size: 11px;
				text-align: center;
			}

			hr
			{
				border: 0;
				height: 1px;
				background-color: #ccc;
				margin: 20px 0px;
			}

			.gui
			{
				color: #ccc;
				background-color: #fff;
				border-bottom: 1px solid #ddd;
				padding: 5px 10px;
				text-align: center;
				text-transform: uppercase;
				line-height: 18px;
				cursor: default;
			}

			.button
			{
				padding: 2px;
				cursor: pointer;
			}

			.key
			{
				padding: 0px 8px;
				margin-left: 1px;
				background-color: #eee;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">

// brushes/circles.js

function circles( context )
{
	this.init( context );
}

circles.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d, cx, cy, steps, step_delta;

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		dx = mouseX - this.prevMouseX;
		dy = mouseY - this.prevMouseY;
		d = Math.sqrt(dx * dx + dy * dy) * 2;

		cx = Math.floor(mouseX / 100) * 100 + 50;
		cy = Math.floor(mouseY / 100) * 100 + 50;

		steps = Math.floor( Math.random() * 10 );
		step_delta = d / steps;

		for (i = 0; i < steps; i++)
		{
			this.context.beginPath();
			this.context.arc( cx, cy, (steps - i) * step_delta, 0, Math.PI*2, true);
			this.context.stroke();
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/chrome.js

function chrome( context )
{
	this.init( context );
}

chrome.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;

		if (RegExp(" AppleWebKit/").test(navigator.userAgent))
			this.context.globalCompositeOperation = 'darker';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";
		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 1000)
			{
				this.context.strokeStyle = "rgba(" + Math.floor(Math.random() * COLOR[0]) + ", " + Math.floor(Math.random() * COLOR[1]) + ", " + Math.floor(Math.random() * COLOR[2]) + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + " )";
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0] + (dx * 0.2), this.points[this.count][1] + (dy * 0.2));
				this.context.lineTo( this.points[i][0] - (dx * 0.2), this.points[i][1] - (dy * 0.2));
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/fur.js

function fur( context )
{
	this.init( context );
}

fur.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 2000 && Math.random() > d / 2000)
			{
				this.context.beginPath();
				this.context.moveTo( mouseX + (dx * 0.5), mouseY + (dy * 0.5));
				this.context.lineTo( mouseX - (dx * 0.5), mouseY - (dy * 0.5));
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/grid.js

function grid( context )
{
	this.init( context );
}

grid.prototype =
{
	context: null,

	init: function( context )
	{
		this.context = context;

		if (RegExp(" AppleWebKit/").test(navigator.userAgent))
			this.context.globalCompositeOperation = 'darker';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
	},

	stroke: function( mouseX, mouseY )
	{
		var i, cx, cy, dx, dy;

		cx = Math.round(mouseX / 100) * 100;
		cy = Math.round(mouseY / 100) * 100;

		dx = (cx - mouseX) * 10;
		dy = (cy - mouseY) * 10;

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.01 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		for (i = 0; i < 50; i++)
		{
			this.context.beginPath();
			this.context.moveTo( cx, cy );
			this.context.quadraticCurveTo(mouseX + Math.random() * dx, mouseY + Math.random() * dy, cx, cy);
			this.context.stroke();
		}
	},

	strokeEnd: function()
	{

	}
}

// brushes/longfur.js

function longfur( context )
{
	this.init( context );
}

longfur.prototype =
{
	context: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
	},

	stroke: function( mouseX, mouseY )
	{
		var i, size, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.05 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		for (i = 0; i < this.points.length; i++)
		{
			size = -Math.random();
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 4000 && Math.random() > d / 4000)
			{
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0] + (dx * size), this.points[this.count][1] + (dy * size));
				this.context.lineTo( this.points[i][0] - (dx * size) + Math.random() * 2, this.points[i][1] - (dy * size) + Math.random() * 2);
				this.context.stroke();
			}
		}

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/ribbon.js

function ribbon( context )
{
	this.init( context );
}

ribbon.prototype =
{
	context: null,

	mouseX: null, mouseY: null,

	painters: null,

	interval: null,

	init: function( context )
	{
		var scope = this;

		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.mouseX = SCREEN_WIDTH / 2;
		this.mouseY = SCREEN_HEIGHT / 2;

		this.painters = new Array();

		for (var i = 0; i < 50; i++)
		{
			this.painters.push({ dx: SCREEN_WIDTH / 2, dy: SCREEN_HEIGHT / 2, ax: 0, ay: 0, div: 0.1, ease: Math.random() * 0.2 + 0.6 });
		}

		this.interval = setInterval( update, 1000/60 );

		function update()
		{
			var i;

			this.context.lineWidth = BRUSH_SIZE;
			this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.05 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

			for (i = 0; i < scope.painters.length; i++)
			{
				scope.context.beginPath();
				scope.context.moveTo(scope.painters[i].dx, scope.painters[i].dy);

				scope.painters[i].dx -= scope.painters[i].ax = (scope.painters[i].ax + (scope.painters[i].dx - scope.mouseX) * scope.painters[i].div) * scope.painters[i].ease;
				scope.painters[i].dy -= scope.painters[i].ay = (scope.painters[i].ay + (scope.painters[i].dy - scope.mouseY) * scope.painters[i].div) * scope.painters[i].ease;
				scope.context.lineTo(scope.painters[i].dx, scope.painters[i].dy);
				scope.context.stroke();
			}
		}
	},

	destroy: function()
	{
		clearInterval(this.interval);
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.mouseX = mouseX;
		this.mouseY = mouseY

		for (var i = 0; i < this.painters.length; i++)
		{
			this.painters[i].dx = mouseX;
			this.painters[i].dy = mouseY;
		}

		this.shouldDraw = true;
	},

	stroke: function( mouseX, mouseY )
	{
		this.mouseX = mouseX;
		this.mouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/shaded.js

function shaded( context )
{
	this.init( context );
}

shaded.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 1000)
			{
				this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + ((1 - (d / 1000)) * 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY) + " )";

				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0], this.points[this.count][1]);
				this.context.lineTo( this.points[i][0], this.points[i][1]);
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/simple.js

function simple( context )
{
	this.init( context );
}

simple.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.5 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/sketchy.js

function sketchy( context )
{
	this.init( context );
}

sketchy.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.05 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 4000 && Math.random() > (d / 2000))
			{
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0] + (dx * 0.3), this.points[this.count][1] + (dy * 0.3));
				this.context.lineTo( this.points[i][0] - (dx * 0.3), this.points[i][1] - (dy * 0.3));
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/squares.js

function squares( context )
{
	this.init( context );
}

squares.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var dx, dy, angle, px, py;

		dx = mouseX - this.prevMouseX;
		dy = mouseY - this.prevMouseY;
		angle = 1.57079633;
		px = Math.cos(angle) * dx - Math.sin(angle) * dy;
		py = Math.sin(angle) * dx + Math.cos(angle) * dy;

		this.context.lineWidth = BRUSH_SIZE;
		this.context.fillStyle = "rgba(" + BACKGROUND_COLOR[0] + ", " + BACKGROUND_COLOR[1] + ", " + BACKGROUND_COLOR[2] + ", " + BRUSH_PRESSURE * BRUSH_OPACITY + ")";
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX - px, this.prevMouseY - py);
		this.context.lineTo(this.prevMouseX + px, this.prevMouseY + py);
		this.context.lineTo(mouseX + px, mouseY + py);
		this.context.lineTo(mouseX - px, mouseY - py);
		this.context.lineTo(this.prevMouseX - px, this.prevMouseY - py);
		this.context.fill();
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/web.js

function web( context )
{
	this.init( context );
}

web.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.5 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";
		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 2500 && Math.random() > 0.9)
			{
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0], this.points[this.count][1]);
				this.context.lineTo( this.points[i][0], this.points[i][1]);
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/eraser.js

function eraser( context )
{
	this.init( context );
}

eraser.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'destination-out';
	},

	destroy: function()
	{
		this.context.globalCompositeOperation = 'source-over';
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(0, 0, 0, 1)";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// colorutils.js

function HSB2RGB(hue, sat, val)
{
	var red, green, blue,
	i, f, p, q, t;

	if (val == 0)
		return [ 0, 0, 0 ];

	hue *= 0.016666667; // /= 60;
	sat *= 0.01; // /= 100;
	val *= 0.01; // /= 100;

	i = Math.floor(hue);
	f = hue - i;
	p = val * (1 - sat);
	q = val * (1 - (sat * f));
	t = val * (1 - (sat * (1 - f)));

	switch(i)
	{
		case 0: red = val; green = t; blue = p; break;
		case 1: red = q; green = val; blue = p; break;
		case 2: red = p; green = val; blue = t; break;
		case 3: red = p; green = q; blue = val; break;
		case 4: red = t; green = p; blue = val; break;
		case 5: red = val; green = p; blue = q; break;
	}

	return [red, green, blue];
}

function RGB2HSB(red, green, blue)
{
	var x, f, i, hue, sat, val;

	x = Math.min( Math.min( red, green ), blue );
	val = Math.max( Math.max( red, green ), blue );

	if (x==val)
		return [0, 0, val*100];

	f = (red == x) ? green - blue : ((green == x) ? blue - red : red - green);
	i = (red == x) ? 3 : ((green == x) ? 5 : 1);

	hue = Math.floor((i - f / (val - x)) * 60) % 360;
	sat = Math.floor(((val - x) / val) * 100);
	val = Math.floor(val * 100);

	return [hue, sat, val];
}

// colorselector.js

function ColorSelector( gradient )
{
	this.init( gradient );
}

ColorSelector.prototype =
{
	container: null,
	color: [0, 0, 0],

	hueSelector: null,
	luminosity: null,
	luminosityData: null,
	luminositySelector: null,
	luminosityPosition: null,

	dispatcher: null,
	changeEvent: null,

	init: function( gradient )
	{
		const DPR = Math.round( window.devicePixelRatio );

		var scope = this, context, hue, hueData;

		this.container = document.createElement('div');
		this.container.style.position = 'absolute';
		this.container.style.width = '250px';
		this.container.style.height = '250px';
		this.container.style.visibility = 'hidden';
		this.container.style.cursor = 'pointer';
		this.container.style.clipPath = 'circle(50.0% at 50% 50%)';
		this.container.addEventListener('mousedown', onMouseDown, false);
		this.container.addEventListener('touchstart', onTouchStart, false);

		hue = document.createElement("canvas");
		hue.width = 250 * DPR;
		hue.height = 250 * DPR;
		hue.style.width = '250px';
		hue.style.height = '250px';

		context = hue.getContext("2d");
		context.drawImage(gradient, 0, 0, hue.width, hue.height);

		hueData = context.getImageData(0, 0, hue.width, hue.height).data;

		this.container.appendChild(hue);

		this.luminosity = document.createElement("canvas");
		this.luminosity.style.position = 'absolute';
		this.luminosity.style.left = '0px';
		this.luminosity.style.top = '0px';
		this.luminosity.width = 250 * DPR;
		this.luminosity.height = 250 * DPR;
		this.luminosity.style.width = '250px';
		this.luminosity.style.height = '250px';

		context = this.luminosity.getContext("2d");
		context.scale(DPR, DPR);
		context.translate(250 / 2, 250 / 2);

		this.container.appendChild(this.luminosity);

		this.hueSelector = document.createElement("canvas");
		this.hueSelector.style.position = 'absolute';
		this.hueSelector.style.left = ((hue.width - 15) / 2 ) + 'px';
		this.hueSelector.style.top = ((hue.height - 15) / 2 ) + 'px';
		this.hueSelector.width = 15 * DPR;
		this.hueSelector.height = 15 * DPR;
		this.hueSelector.style.width = '15px';
		this.hueSelector.style.height = '15px';

		context = this.hueSelector.getContext("2d");
		context.scale(DPR, DPR);
		context.lineWidth = 2;
		context.strokeStyle = "rgba(0, 0, 0, 0.5)";
		context.beginPath();
		context.arc(8, 8, 6, 0, Math.PI * 2, true);
		context.stroke();
		context.strokeStyle = "rgba(256, 256, 256, 0.8)";
		context.beginPath();
		context.arc(7, 7, 6, 0, Math.PI * 2, true);
		context.stroke();

		this.container.appendChild( this.hueSelector );

		this.luminosityPosition = [ (gradient.width - 15), (gradient.height - 15) / 2 ];

		this.luminositySelector = document.createElement("canvas");
		this.luminositySelector.style.position = 'absolute';
		this.luminositySelector.style.left = (this.luminosityPosition[0] - 7) + 'px';
		this.luminositySelector.style.top = (this.luminosityPosition[1] - 7) + 'px';
		this.luminositySelector.width = 15 * DPR;
		this.luminositySelector.height = 15 * DPR;
		this.luminositySelector.style.width = '15px';
		this.luminositySelector.style.height = '15px';

		context = this.luminositySelector.getContext("2d");
		context.drawImage(this.hueSelector, 0, 0, this.luminositySelector.width, this.luminositySelector.height);

		this.container.appendChild(this.luminositySelector);

		this.dispatcher = document.createElement('div'); // this could be better handled...

		this.changeEvent = document.createEvent('Events');
		this.changeEvent.initEvent('change', true, true);

		//

		function onMouseDown( event )
		{
			window.addEventListener('mousemove', onMouseMove, false);
			window.addEventListener('mouseup', onMouseUp, false);

			update( event.clientX - scope.container.offsetLeft, event.clientY - scope.container.offsetTop );
		}

		function onMouseMove( event )
		{
			update( event.clientX - scope.container.offsetLeft, event.clientY - scope.container.offsetTop );
		}

		function onMouseUp( event )
		{
			window.removeEventListener('mousemove', onMouseMove, false);
			window.removeEventListener('mouseup', onMouseUp, false);
		}

		function onTouchStart( event )
		{
			if(event.touches.length == 1)
			{
				event.preventDefault();

				window.addEventListener('touchmove', onTouchMove, false);
				window.addEventListener('touchend', onTouchEnd, false);

				update( event.touches[0].pageX - scope.container.offsetLeft, event.touches[0].pageY - scope.container.offsetTop );
			}
		}

		function onTouchMove( event )
		{
			if(event.touches.length == 1)
			{
				event.preventDefault();

				update( event.touches[0].pageX - scope.container.offsetLeft, event.touches[0].pageY - scope.container.offsetTop );
			}
		}

		function onTouchEnd( event )
		{
			if(event.touches.length == 0)
			{
				event.preventDefault();

				window.removeEventListener('touchmove', onTouchMove, false);
				window.removeEventListener('touchend', onTouchEnd, false);
			}
		}

		//

		function update(x, y)
		{
			var dx, dy, d, nx, ny;

			dx = x - 125;
			dy = y - 125;
			d = Math.sqrt( dx * dx + dy * dy );

			if (d < 90)
			{
				scope.hueSelector.style.left = (x - 7) + 'px';
				scope.hueSelector.style.top = (y - 7) + 'px';

				var index = Math.round( (x * DPR) + ((y * DPR) * (250 * DPR)) ) * 4;
				scope.updateLuminosity( hueData[index + 0], hueData[index + 1], hueData[index + 2] );
			}
			else if (d > 100)
			{
				nx = dx / d;
				ny = dy / d;

				scope.luminosityPosition[0] = (nx * 110) + 125;
				scope.luminosityPosition[1] = (ny * 110) + 125;

				scope.luminositySelector.style.left = ( scope.luminosityPosition[0] - 7) + 'px';
				scope.luminositySelector.style.top = ( scope.luminosityPosition[1] - 7) + 'px';
			}

			x = Math.floor(scope.luminosityPosition[0]);
			y = Math.floor(scope.luminosityPosition[1]);

			var index = ((x * DPR) + ((y * DPR) * (250 * DPR))) * 4;
			scope.color[0] = scope.luminosityData[index + 0];
			scope.color[1] = scope.luminosityData[index + 1];
			scope.color[2] = scope.luminosityData[index + 2];

			scope.dispatchEvent( scope.changeEvent );
		}
	},


	//

	show: function()
	{
		this.container.style.visibility = 'visible';
	},

	hide: function()
	{
		this.container.style.visibility = 'hidden';
	},

	getColor: function()
	{
		return this.color;
	},

	setColor: function( color )
	{
		// Ok, this is super dirty. The whole class needs some refactoring, again! :/

		var hsb, angle, distance, rgb, DEG2RAD = Math.PI / 180;

		this.color = color;

		hsb = RGB2HSB(color[0] / 255, color[1] / 255, color[2] / 255);

		angle = hsb[0] * DEG2RAD;
		distance = (hsb[1] / 100) * 90;

		this.hueSelector.style.left = ( ( Math.cos(angle) * distance + 125 ) - 7 ) + 'px';
		this.hueSelector.style.top = ( ( Math.sin(angle) * distance + 125 ) - 7 ) + 'px';

		rgb = HSB2RGB(hsb[0], hsb[1], 100);
		rgb[0] *= 255; rgb[1] *= 255; rgb[2] *= 255;

		this.updateLuminosity( rgb[0], rgb[1], rgb[2] );

		angle = (hsb[2] / 100) * 360 * DEG2RAD;

		this.luminosityPosition[0] = ( Math.cos(angle) * 110 ) + 125;
		this.luminosityPosition[1] = ( Math.sin(angle) * 110 ) + 125;

		this.luminositySelector.style.left = ( this.luminosityPosition[0] - 7 ) + 'px';
		this.luminositySelector.style.top = ( this.luminosityPosition[1] - 7 ) + 'px';

		this.dispatchEvent( this.changeEvent );
	},

	//

	updateLuminosity: function( r, g, b )
	{
		var context, angle, angle_cos, angle_sin, shade, radius = 110,
		i, count = 360, DEG2RAD = Math.PI / 180;

		context = this.luminosity.getContext("2d");
		context.clearRect(0, 0, this.luminosity.width, this.luminosity.height);

		const map = (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2;

		for(i = 0; i < count; i++)
		{
			angle = map( i, 0, count, 5, 355 ) * DEG2RAD;
			angle_cos = Math.cos(angle);
			angle_sin = Math.sin(angle);

			shade = i / count;

			context.fillStyle = "rgb(" + Math.floor( r * shade ) + "," + Math.floor( g * shade ) + "," + Math.floor( b * shade ) + ")";
			context.beginPath();
			context.arc(angle_cos * radius, angle_sin * radius, 10, 0, Math.PI * 2);
			context.fill();

		}

		this.luminosityData = context.getImageData(0, 0, this.luminosity.width, this.luminosity.height).data;
	},

	//

	addEventListener: function( type, listener, useCapture )
	{
		this.dispatcher.addEventListener(type, listener, useCapture);
	},

	dispatchEvent: function( event )
	{
		this.dispatcher.dispatchEvent(event);
	},

	removeEventListener: function( type, listener, useCapture )
	{
		this.dispatcher.removeEventListener(type, listener, useCapture);
	}
}

// palette.js

function Palette()
{
	const DPR = Math.round(window.devicePixelRatio);

	var canvas, context, radius = 90, gradient;

	canvas = document.createElement("canvas");
	canvas.width = 250 * DPR;
	canvas.height = 250 * DPR;

	context = canvas.getContext("2d");
	context.scale(DPR, DPR);

	gradient = context.createConicGradient(0, 125, 125);

	for(hue = 0; hue < 360; hue++)
	{
		gradient.addColorStop(hue / 360, 'hsl(' + hue + ', 100%, 50%)');
	}

	context.beginPath();
	context.arc(125, 125, radius, 0, Math.PI * 2);
	context.fillStyle = gradient;
	context.fill();

	gradient = context.createRadialGradient(125, 125, 0, 125, 125, radius);
	gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
	gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

	context.beginPath();
	context.arc(125, 125, radius, 0, Math.PI * 2);
	context.fillStyle = gradient;
	context.fill();

	return canvas;
}

// menu.js

function Menu()
{
	this.init();
}

Menu.prototype =
{
	container: null,

	foregroundColor: null,
	backgroundColor: null,

	selector: null,
	opacitySlider: null,
	opacityLabel: null,
	symmetrySelector: null,
	save: null,
	download: null,
	upload: null,
	undo: null,
	redo: null,
	clear: null,
	about: null,
	zoomIndicator: null,
	zoomReset: null,

	isDragged: false,

	init: function()
	{
		var scope = this;
		var option, space, separator, color_width = 15, color_height = 15;

		this.container = document.createElement("div");
		this.container.className = 'gui';
		this.container.style.position = 'absolute';
		this.container.style.top = '0px';

		// Drag handle
		this.dragHandle = document.createElement("span");
		this.dragHandle.innerHTML = '&#9776;';
		this.dragHandle.style.cursor = 'grab';
		this.dragHandle.style.marginRight = '6px';
		this.dragHandle.style.userSelect = 'none';
		this.dragHandle.style.color = '#888';
		this.dragHandle.style.fontSize = '16px';
		this.dragHandle.style.verticalAlign = 'middle';
		this.container.appendChild(this.dragHandle);

		// Drag logic
		var dragOffsetX = 0, dragOffsetY = 0;

		function onDragStart( event )
		{
			event.preventDefault();
			event.stopPropagation();
			var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
			var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
			dragOffsetX = clientX - scope.container.offsetLeft;
			dragOffsetY = clientY - scope.container.offsetTop;
			scope.dragHandle.style.cursor = 'grabbing';
			window.addEventListener('mousemove', onDragMove, false);
			window.addEventListener('mouseup', onDragEnd, false);
			window.addEventListener('touchmove', onDragMove, { passive: false });
			window.addEventListener('touchend', onDragEnd, false);
		}

		function onDragMove( event )
		{
			event.preventDefault();
			var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
			var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
			scope.container.style.left = (clientX - dragOffsetX) + 'px';
			scope.container.style.top = (clientY - dragOffsetY) + 'px';
			scope.isDragged = true;
		}

		function onDragEnd( event )
		{
			scope.dragHandle.style.cursor = 'grab';
			window.removeEventListener('mousemove', onDragMove, false);
			window.removeEventListener('mouseup', onDragEnd, false);
			window.removeEventListener('touchmove', onDragMove, false);
			window.removeEventListener('touchend', onDragEnd, false);
		}

		this.dragHandle.addEventListener('mousedown', onDragStart, false);
		this.dragHandle.addEventListener('touchstart', onDragStart, { passive: false });

		this.foregroundColor = document.createElement("canvas");
		this.foregroundColor.style.marginBottom = '-3px';
		this.foregroundColor.style.cursor = 'pointer';
		this.foregroundColor.width = color_width;
		this.foregroundColor.height = color_height;
		this.container.appendChild(this.foregroundColor);

		this.setForegroundColor( COLOR );

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.backgroundColor = document.createElement("canvas");
		this.backgroundColor.style.marginBottom = '-3px';
		this.backgroundColor.style.cursor = 'pointer';
		this.backgroundColor.width = color_width;
		this.backgroundColor.height = color_height;
		this.container.appendChild(this.backgroundColor);

		this.setBackgroundColor( BACKGROUND_COLOR );

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.selector = document.createElement("select");

		for (i = 0; i < BRUSHES.length; i++)
		{
			option = document.createElement("option");
			option.id = i;
			option.innerHTML = BRUSHES[i].toUpperCase();
			this.selector.appendChild(option);
		}

		this.container.appendChild(this.selector);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.opacityLabel = document.createElement("span");
		this.opacityLabel.style.fontSize = '11px';
		this.opacityLabel.innerHTML = '100%';
		this.container.appendChild(this.opacityLabel);

		this.opacitySlider = document.createElement("input");
		this.opacitySlider.type = 'range';
		this.opacitySlider.min = '0';
		this.opacitySlider.max = '100';
		this.opacitySlider.value = '100';
		this.opacitySlider.style.width = '60px';
		this.opacitySlider.style.verticalAlign = 'middle';
		this.opacitySlider.style.margin = '0 4px';
		this.container.appendChild(this.opacitySlider);

		this.opacitySlider.addEventListener('input', function() {
			BRUSH_OPACITY = scope.opacitySlider.value / 100;
			scope.opacityLabel.innerHTML = scope.opacitySlider.value + '%';
		}, false);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.symmetrySelector = document.createElement("select");
		var symOptions = [
			{ label: "Sym: Off", value: "0" },
			{ label: "2", value: "2" },
			{ label: "3", value: "3" },
			{ label: "4", value: "4" },
			{ label: "6", value: "6" },
			{ label: "8", value: "8" }
		];
		for (var s = 0; s < symOptions.length; s++)
		{
			option = document.createElement("option");
			option.value = symOptions[s].value;
			option.innerHTML = symOptions[s].label;
			this.symmetrySelector.appendChild(option);
		}
		this.container.appendChild(this.symmetrySelector);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.save = document.createElement("span"); //getElementById('save');
		this.save.className = 'button';
		this.save.innerHTML = 'Save';
		this.container.appendChild(this.save);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.download = document.createElement("span");
		this.download.className = 'button';
		this.download.innerHTML = 'Download';
		this.container.appendChild(this.download);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.upload = document.createElement("span");
		this.upload.className = 'button';
		this.upload.innerHTML = 'Upload';
		this.container.appendChild(this.upload);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.undo = document.createElement("span");
		this.undo.className = 'button';
		this.undo.innerHTML = 'Undo';
		this.container.appendChild(this.undo);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.redo = document.createElement("span");
		this.redo.className = 'button';
		this.redo.innerHTML = 'Redo';
		this.container.appendChild(this.redo);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.clear = document.createElement("Clear");
		this.clear.className = 'button';
		this.clear.innerHTML = 'Clear';
		this.container.appendChild(this.clear);

		separator = document.createTextNode(" | ");
		this.container.appendChild(separator);

		this.zoomIndicator = document.createElement("span");
		this.zoomIndicator.style.padding = '2px 4px';
		this.zoomIndicator.style.fontSize = '11px';
		this.zoomIndicator.innerHTML = '1.0x';
		this.container.appendChild(this.zoomIndicator);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.zoomReset = document.createElement("span");
		this.zoomReset.className = 'button';
		this.zoomReset.innerHTML = 'Reset Zoom';
		this.container.appendChild(this.zoomReset);

		separator = document.createTextNode(" | ");
		this.container.appendChild(separator);

		this.about = document.createElement("About");
		this.about.className = 'button';
		this.about.innerHTML = 'About';
		this.container.appendChild(this.about);
	},

	setForegroundColor: function( color )
	{
		var context = this.foregroundColor.getContext("2d");
		context.fillStyle = 'rgb(' + color[0] + ', ' + color[1] +', ' + color[2] + ')';
		context.fillRect(0, 0, this.foregroundColor.width, this.foregroundColor.height);
		context.fillStyle = 'rgba(0, 0, 0, 0.1)';
		context.fillRect(0, 0, this.foregroundColor.width, 1);
	},

	setBackgroundColor: function( color )
	{
		var context = this.backgroundColor.getContext("2d");
		context.fillStyle = 'rgb(' + color[0] + ', ' + color[1] +', ' + color[2] + ')';
		context.fillRect(0, 0, this.backgroundColor.width, this.backgroundColor.height);
		context.fillStyle = 'rgba(0, 0, 0, 0.1)';
		context.fillRect(0, 0, this.backgroundColor.width, 1);
	},

	setZoomLevel: function( level )
	{
		this.zoomIndicator.innerHTML = level.toFixed(1) + 'x';
	}
}

// about.js

function About()
{
	this.init();
}

About.prototype =
{
	container: null,

	init: function()
	{
		var text, containerText;

		this.container = document.createElement("div");
		this.container.className = 'gui';
		this.container.style.position = 'absolute';
		this.container.style.top = '0px';
		this.container.style.visibility = 'hidden';
		this.container.style.width = '280px';
		this.container.style.whiteSpace = 'normal';

		containerText = document.createElement("div");
		containerText.style.margin = '10px 10px';
		containerText.style.textAlign = 'left';
		this.container.appendChild(containerText);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<strong>HARMONY</strong> <a href="changelog.txt" target="_blank">r' + REV + '</a> by <a href="http://twitter.com/mrdoob" target="_blank">Mr.doob</a>';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = 'Brush: <span class="key">d</span><span class="key">f</span> size, <span class="key">r</span> reset<br />Color: <span class="key">shift</span> wheel, <span class="key">alt</span> picker<br />';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<a href="http://mrdoob.com/blog/post/689" target="_blank">Info</a> - <a href="http://github.com/mrdoob/harmony" target="_blank">Source Code</a>';
		containerText.appendChild(text);

		text = document.createElement("hr");
		containerText.appendChild(text);

		text = document.createElement("p");
		text.innerHTML = '<em>Sketchy</em>, <em>Shaded</em>, <em>Chrome</em>, <em>Fur</em>, <em>LongFur</em> and <em>Web</em> are all variations of the neighbour points connection concept. First implemented in <a href="http://www.zefrank.com/scribbler/" target="_blank">The Scribbler</a>.';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.innerHTML = 'If you like the tool, you can use this button to share your love ;)';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank"><input type="hidden" name="cmd" value="_s-xclick"><input type="hidden" name="hosted_button_id" value="VY7767JMMMYM4"><input type="image" src="https://www.paypal.com/en_GB/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online."><img alt="" border="0" src="https://www.paypal.com/en_GB/i/scr/pixel.gif" width="1" height="1"></form>';
		containerText.appendChild(text);
	},

	show: function()
	{
		this.container.style.visibility = 'visible';
	},

	hide: function()
	{
		this.container.style.visibility = 'hidden';
	}
}

// main.js

const REV = 9;
const BRUSHES = ["sketchy", "shaded", "chrome", "fur", "longfur", "web", "", "simple", "squares", "ribbon", "", "circles", "grid", "eraser"];
const USER_AGENT = navigator.userAgent.toLowerCase();

var SCREEN_WIDTH = window.innerWidth,
    SCREEN_HEIGHT = window.innerHeight,
    PIXEL_RATIO = Math.max( 1, window.devicePixelRatio ),
    BRUSH_SIZE = 1,
    BRUSH_PRESSURE = 1,
    BRUSH_OPACITY = 1,
    SYMMETRY_AXES = 0,
    symmetryBrushes = [],
    COLOR = [0, 0, 0],
    BACKGROUND_COLOR = [250, 250, 250],
    STORAGE = window.localStorage,
    brush,
    saveTimeOut,
    wacom,
    i,
    mouseX = 0,
    mouseY = 0,
    container,
    foregroundColorSelector,
    backgroundColorSelector,
    menu,
    about,
    canvas,
    flattenCanvas,
    context,
    isFgColorSelectorVisible = false,
    isBgColorSelectorVisible = false,
    isAboutVisible = false,
    isMenuMouseOver = false,
    shiftKeyIsDown = false,
    altKeyIsDown = false,
    isDrawing = false,
    multiTouchFingers = 0,
    undoHistory = [],
    historyIndex = -1,
    HISTORY_MAX = 30,
    zoomLevel = 1,
    panX = 0,
    panY = 0,
    pinchStartDist = 0,
    pinchStartZoom = 1,
    isPinching = false,
    lastPinchCenterX = 0,
    lastPinchCenterY = 0,
    ZOOM_MIN = 1,
    ZOOM_MAX = 50;

init();

function screenToCanvas(x, y)
{
	return {
		x: (x - panX) / zoomLevel,
		y: (y - panY) / zoomLevel
	};
}

function applyZoomTransform()
{
	canvas.style.transformOrigin = '0 0';
	canvas.style.transform = 'translate(' + panX + 'px, ' + panY + 'px) scale(' + zoomLevel + ')';
	if (menu) menu.setZoomLevel(zoomLevel);
}

function clampPan()
{
	var maxPanX = 0;
	var maxPanY = 0;
	var minPanX = SCREEN_WIDTH - SCREEN_WIDTH * zoomLevel;
	var minPanY = SCREEN_HEIGHT - SCREEN_HEIGHT * zoomLevel;
	panX = Math.min(maxPanX, Math.max(minPanX, panX));
	panY = Math.min(maxPanY, Math.max(minPanY, panY));
}

function init()
{
	var hash, palette, embed, localStorageImage;

	if (USER_AGENT.search("android") > -1 || USER_AGENT.search("iphone") > -1)
		BRUSH_SIZE = 2;

	if (USER_AGENT.search("safari") > -1 && USER_AGENT.search("chrome") == -1) // Safari
		STORAGE = false;

	document.body.style.backgroundRepeat = 'no-repeat';
	document.body.style.backgroundPosition = 'center center';

	container = document.createElement('div');
	document.body.appendChild(container);

	/*
	 * TODO: In some browsers a naste "Plugin Missing" window appears and people is getting confused.
	 * Disabling it until a better way to handle it appears.
	 *
	 * embed = document.createElement('embed');
	 * embed.id = 'wacom-plugin';
	 * embed.type = 'application/x-wacom-tablet';
	 * document.body.appendChild(embed);
	 *
	 * wacom = document.embeds["wacom-plugin"];
	 */

	canvas = document.createElement("canvas");
	canvas.width = SCREEN_WIDTH * PIXEL_RATIO;
	canvas.height = SCREEN_HEIGHT * PIXEL_RATIO;
	canvas.style.cursor = 'crosshair';
	canvas.style.width = SCREEN_WIDTH + 'px';
	canvas.style.height = SCREEN_HEIGHT + 'px';
	container.appendChild(canvas);

	context = canvas.getContext("2d");
	context.save();
	context.scale(PIXEL_RATIO, PIXEL_RATIO);

	flattenCanvas = document.createElement("canvas");
	flattenCanvas.width = SCREEN_WIDTH * PIXEL_RATIO;
	flattenCanvas.height = SCREEN_HEIGHT * PIXEL_RATIO;

	palette = new Palette();

	foregroundColorSelector = new ColorSelector(palette);
	foregroundColorSelector.addEventListener('change', onForegroundColorSelectorChange, false);
	container.appendChild(foregroundColorSelector.container);

	backgroundColorSelector = new ColorSelector(palette);
	backgroundColorSelector.addEventListener('change', onBackgroundColorSelectorChange, false);
	container.appendChild(backgroundColorSelector.container);

	menu = new Menu();
	menu.foregroundColor.addEventListener('click', onMenuForegroundColor, false);
	menu.foregroundColor.addEventListener('touchend', onMenuForegroundColor, { passive: false });
	menu.backgroundColor.addEventListener('click', onMenuBackgroundColor, false);
	menu.backgroundColor.addEventListener('touchend', onMenuBackgroundColor, false);
	menu.selector.addEventListener('change', onMenuSelectorChange, false);
	menu.symmetrySelector.addEventListener('change', onMenuSymmetryChange, false);
	menu.save.addEventListener('click', onMenuSave, false);
	menu.save.addEventListener('touchend', onMenuSave, false);
	menu.download.addEventListener('click', onMenuDownload, false);
	menu.download.addEventListener('touchend', onMenuDownload, false);
	menu.upload.addEventListener('click', onMenuUpload, false);
	menu.upload.addEventListener('touchend', onMenuUpload, false);
	menu.undo.addEventListener('click', onMenuUndo, false);
	menu.undo.addEventListener('touchend', onMenuUndo, false);
	menu.redo.addEventListener('click', onMenuRedo, false);
	menu.redo.addEventListener('touchend', onMenuRedo, false);
	menu.clear.addEventListener('click', onMenuClear, false);
	menu.clear.addEventListener('touchend', onMenuClear, false);
	menu.about.addEventListener('click', onMenuAbout, false);
	menu.about.addEventListener('touchend', onMenuAbout, false);
	menu.zoomReset.addEventListener('click', onMenuZoomReset, false);
	menu.zoomReset.addEventListener('touchend', onMenuZoomReset, false);
	menu.container.addEventListener('mouseover', onMenuMouseOver, { passive: false });
	menu.container.addEventListener('mouseout', onMenuMouseOut, { passive: false });
	container.appendChild(menu.container);

	if (STORAGE)
	{
		if (localStorage['harmony-canvas'])
		{
			localStorageImage = new Image();

			localStorageImage.addEventListener("load", function(event)
			{
				localStorageImage.removeEventListener(event.type, arguments.callee, false);
				context.restore();
				context.drawImage(localStorageImage,0,0);
				context.scale(PIXEL_RATIO, PIXEL_RATIO);
				saveToHistory();
			}, false);

			localStorageImage.src = localStorage['harmony-canvas'];
		}

		if (localStorage['harmony-bg'])
		{
			let array = JSON.parse(localStorage['harmony-color']);

			COLOR[0] = array[0];
			COLOR[1] = array[1];
			COLOR[2] = array[2];
		}

		if (localStorage['harmony-bg'])
		{
			let array = JSON.parse(localStorage['harmony-bg']);

			BACKGROUND_COLOR[0] = array[0];
			BACKGROUND_COLOR[1] = array[1];
			BACKGROUND_COLOR[2] = array[2];
		}
	}

	foregroundColorSelector.setColor( COLOR );
	backgroundColorSelector.setColor( BACKGROUND_COLOR );

	if (window.location.hash)
	{
		hash = window.location.hash.substr(1,window.location.hash.length);

		for (i = 0; i < BRUSHES.length; i++)
		{
			if (hash == BRUSHES[i])
			{
				brush = eval("new " + BRUSHES[i] + "(context)");
				menu.selector.selectedIndex = i;
				break;
			}
		}
	}

	if (!brush)
	{
		brush = eval("new " + BRUSHES[0] + "(context)");
	}

	about = new About();
	container.appendChild(about.container);

	window.addEventListener('mousemove', onWindowMouseMove, false);
	window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('keydown', onWindowKeyDown, false);
	window.addEventListener('keyup', onWindowKeyUp, false);
	window.addEventListener('blur', onWindowBlur, false);

	document.addEventListener('mousedown', onDocumentMouseDown, false);
	document.addEventListener('mouseout', onDocumentMouseOut, false);

	document.addEventListener("dragenter", onDocumentDragEnter, false);
	document.addEventListener("dragover", onDocumentDragOver, false);
	document.addEventListener("drop", onDocumentDrop, false);

	canvas.addEventListener('mousedown', onCanvasMouseDown, { passive: false });
	canvas.addEventListener('touchstart', onCanvasTouchStart, { passive: false });
	canvas.addEventListener('wheel', onCanvasWheel, { passive: false });

	onWindowResize(null);

	saveToHistory();
}


// SYMMETRY

function getSymmetryPoints(x, y)
{
	if (SYMMETRY_AXES <= 1) return [];
	var cx = SCREEN_WIDTH / 2, cy = SCREEN_HEIGHT / 2;
	var points = [];
	for (var i = 1; i < SYMMETRY_AXES; i++)
	{
		var angle = (i * 2 * Math.PI) / SYMMETRY_AXES;
		var dx = x - cx, dy = y - cy;
		var rx = cx + dx * Math.cos(angle) - dy * Math.sin(angle);
		var ry = cy + dx * Math.sin(angle) + dy * Math.cos(angle);
		points.push({x: rx, y: ry});
	}
	return points;
}

function recreateSymmetryBrushes()
{
	for (var i = 0; i < symmetryBrushes.length; i++)
	{
		symmetryBrushes[i].destroy();
	}
	symmetryBrushes = [];
	if (SYMMETRY_AXES > 1)
	{
		for (var i = 1; i < SYMMETRY_AXES; i++)
		{
			symmetryBrushes.push(eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)"));
		}
	}
}

// WINDOW

function onWindowMouseMove( event )
{
	mouseX = event.clientX;
	mouseY = event.clientY;
}

function onWindowResize()
{
	SCREEN_WIDTH = window.innerWidth;
	SCREEN_HEIGHT = window.innerHeight;

	if (!menu.isDragged)
		menu.container.style.left = ((SCREEN_WIDTH - menu.container.offsetWidth) / 2) + 'px';

	about.container.style.left = ((SCREEN_WIDTH - about.container.offsetWidth) / 2) + 'px';
	about.container.style.top = ((SCREEN_HEIGHT - about.container.offsetHeight) / 2) + 'px';
}

function onWindowKeyDown( event )
{
	if (event.keyCode === 90 && (event.ctrlKey || event.metaKey))
	{
		event.preventDefault();
		if (event.shiftKey)
			onMenuRedo();
		else
			onMenuUndo();
		return;
	}

	if (shiftKeyIsDown)
		return;

	switch(event.keyCode)
	{
		case 16: // Shift
			shiftKeyIsDown = true;
			foregroundColorSelector.container.style.left = mouseX - 125 + 'px';
			foregroundColorSelector.container.style.top = mouseY - 125 + 'px';
			foregroundColorSelector.container.style.visibility = 'visible';
			break;

		case 18: // Alt
			altKeyIsDown = true;
			break;

		case 68: // d
			if(BRUSH_SIZE > 1) BRUSH_SIZE --;
			break;

		case 70: // f
			BRUSH_SIZE ++;
			break;
	}
}

function onWindowKeyUp( event )
{
	switch(event.keyCode)
	{
		case 16: // Shift
			shiftKeyIsDown = false;
			foregroundColorSelector.container.style.visibility = 'hidden';
			break;

		case 18: // Alt
			altKeyIsDown = false;
			break;

		case 82: // r
			brush.destroy();
			brush = eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)");
			recreateSymmetryBrushes();
			break;
		case 66: // b
			document.body.style.backgroundImage = null;
			break;
	}

	context.lineCap = BRUSH_SIZE == 1 ? 'butt' : 'round';
}

function onWindowBlur( event )
{
	shiftKeyIsDown = false;
	altKeyIsDown = false;
}


// DOCUMENT

function onDocumentMouseDown( event )
{
	if (!isMenuMouseOver)
		event.preventDefault();
}

function onDocumentMouseOut( event )
{
	onCanvasMouseUp();
}

function onDocumentDragEnter( event )
{
	event.stopPropagation();
	event.preventDefault();
}

function onDocumentDragOver( event )
{
	event.stopPropagation();
	event.preventDefault();
}

function onDocumentDrop( event )
{
	event.stopPropagation();
	event.preventDefault();

	var file = event.dataTransfer.files[0];

	if (file.type.match(/image.*/))
	{
		/*
		 * TODO: This seems to work on Chromium. But not on Firefox.
		 * Better wait for proper FileAPI?
		 */

		var fileString = event.dataTransfer.getData('text').split("\n");
		document.body.style.backgroundImage = 'url(' + fileString[0] + ')';
	}
}


// COLOR SELECTORS

function onForegroundColorSelectorChange( event )
{
	COLOR = foregroundColorSelector.getColor();

	menu.setForegroundColor( COLOR );

	if (STORAGE)
	{
		localStorage['harmony-color'] = JSON.stringify(COLOR);
	}
}

function onBackgroundColorSelectorChange( event )
{
	BACKGROUND_COLOR = backgroundColorSelector.getColor();

	menu.setBackgroundColor( BACKGROUND_COLOR );

	document.body.style.backgroundColor = 'rgb(' + BACKGROUND_COLOR[0] + ', ' + BACKGROUND_COLOR[1] + ', ' + BACKGROUND_COLOR[2] + ')';

	if (STORAGE)
	{
		localStorage['harmony-bg'] = JSON.stringify(BACKGROUND_COLOR);
	}
}


// MENU

function onMenuForegroundColor()
{
	cleanPopUps();

	foregroundColorSelector.show();
	foregroundColorSelector.container.style.left = ((SCREEN_WIDTH - foregroundColorSelector.container.offsetWidth) / 2) + 'px';
	foregroundColorSelector.container.style.top = ((SCREEN_HEIGHT - foregroundColorSelector.container.offsetHeight) / 2) + 'px';

	isFgColorSelectorVisible = true;
}

function onMenuBackgroundColor()
{
	cleanPopUps();

	backgroundColorSelector.show();
	backgroundColorSelector.container.style.left = ((SCREEN_WIDTH - backgroundColorSelector.container.offsetWidth) / 2) + 'px';
	backgroundColorSelector.container.style.top = ((SCREEN_HEIGHT - backgroundColorSelector.container.offsetHeight) / 2) + 'px';

	isBgColorSelectorVisible = true;
}

function onMenuSelectorChange()
{
	if (BRUSHES[menu.selector.selectedIndex] == "")
		return;

	brush.destroy();
	brush = eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)");
	recreateSymmetryBrushes();

	window.location.hash = BRUSHES[menu.selector.selectedIndex];
}

function onMenuSymmetryChange()
{
	SYMMETRY_AXES = parseInt(menu.symmetrySelector.value, 10);
	recreateSymmetryBrushes();
}

function onMenuMouseOver()
{
	isMenuMouseOver = true;
}

function onMenuMouseOut()
{
	isMenuMouseOver = false;
}

function onMenuSave()
{
	if (STORAGE)
	{
		saveToLocalStorage();
	}
}

function onMenuDownload()
{
	flatten();

	var data = flattenCanvas.toDataURL('image/png');

	var historyData = [];
	var tempCanvas = document.createElement('canvas');
	tempCanvas.width = canvas.width;
	tempCanvas.height = canvas.height;
	var tempCtx = tempCanvas.getContext('2d');

	for (var i = 0; i < undoHistory.length; i++)
	{
		tempCtx.putImageData(undoHistory[i], 0, 0);
		historyData.push(tempCanvas.toDataURL('image/png'));
	}

	var metadata = '<metadata><harmony:history xmlns:harmony="urn:harmony" index="' + historyIndex + '">'
		+ '<![CDATA[' + JSON.stringify(historyData) + ']]>'
		+ '</harmony:history></metadata>';

	var svg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + SCREEN_WIDTH + '" height="' + SCREEN_HEIGHT + '">'
		+ metadata
		+ '<image width="' + SCREEN_WIDTH + '" height="' + SCREEN_HEIGHT + '" xlink:href="' + data + '"/>'
		+ '</svg>';

	var blob = new Blob([svg], { type: 'image/svg+xml' });
	var url = URL.createObjectURL(blob);

	var a = document.createElement('a');
	a.href = url;
	var d = new Date();
	var dateStr = d.getFullYear().toString() +
		(d.getMonth() + 1).toString().padStart(2, '0') +
		d.getDate().toString().padStart(2, '0');
	a.download = 'harmony_' + dateStr + '.svg';
	a.click();

	URL.revokeObjectURL(url);
}

function onMenuUpload()
{
	var input = document.createElement('input');
	input.type = 'file';
	input.accept = '.svg,image/svg+xml';

	input.addEventListener('change', function()
	{
		var file = input.files[0];

		if (!file)
			return;

		var textReader = new FileReader();

		textReader.addEventListener('load', function()
		{
			var svgText = textReader.result;
			var parser = new DOMParser();
			var doc = parser.parseFromString(svgText, 'image/svg+xml');
			var historyEl = doc.getElementsByTagNameNS('urn:harmony', 'history')[0];
			var savedHistory = null;
			var savedIndex = -1;

			if (historyEl)
			{
				try
				{
					savedHistory = JSON.parse(historyEl.textContent);
					savedIndex = parseInt(historyEl.getAttribute('index'), 10);
				}
				catch(e)
				{
					savedHistory = null;
				}
			}

			var imageEl = doc.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')[0];
			var href = imageEl ? (imageEl.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || imageEl.getAttribute('href')) : null;

			if (!href)
				return;

			var image = new Image();

			image.addEventListener('load', function()
			{
				context.setTransform(1, 0, 0, 1, 0, 0);
				context.clearRect(0, 0, canvas.width, canvas.height);
				context.drawImage(image, 0, 0);
				context.setTransform(PIXEL_RATIO, 0, 0, PIXEL_RATIO, 0, 0);

				saveToLocalStorage();

				if (savedHistory && savedHistory.length > 0)
				{
					var loaded = 0;
					var newHistory = new Array(savedHistory.length);

					for (var i = 0; i < savedHistory.length; i++)
					{
						(function(idx)
						{
							var img = new Image();

							img.addEventListener('load', function()
							{
								var tempCanvas = document.createElement('canvas');
								tempCanvas.width = canvas.width;
								tempCanvas.height = canvas.height;
								var tempCtx = tempCanvas.getContext('2d');
								tempCtx.drawImage(img, 0, 0);
								newHistory[idx] = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

								loaded++;

								if (loaded === savedHistory.length)
								{
									undoHistory = newHistory;
									historyIndex = savedIndex;
								}
							}, false);

							img.src = savedHistory[idx];
						})(i);
					}
				}
				else
				{
					saveToHistory();
				}
			}, false);

			image.src = href;
		}, false);

		textReader.readAsText(file);
	}, false);

	input.click();
}

function onMenuClear()
{
	if (!confirm("Are you sure?"))
		return;

	context.clearRect(0, 0, SCREEN_WIDTH * PIXEL_RATIO, SCREEN_HEIGHT * PIXEL_RATIO);

	saveToLocalStorage();
	saveToHistory();

	brush.destroy();
	brush = eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)");
	recreateSymmetryBrushes();
}

function onMenuAbout()
{
	cleanPopUps();

	isAboutVisible = true;
	about.show();
}


// CANVAS

function onCanvasMouseDown( event )
{
	var data, position;

	clearTimeout(saveTimeOut);
	cleanPopUps();

	if (altKeyIsDown)
	{
		flatten();

		data = flattenCanvas.getContext("2d").getImageData(0, 0, flattenCanvas.width, flattenCanvas.height).data;
		var canvasPos = screenToCanvas(event.clientX, event.clientY);
		position = (Math.round(canvasPos.x) + (Math.round(canvasPos.y) * canvas.width)) * 4;

		foregroundColorSelector.setColor( [ data[position], data[position + 1], data[position + 2] ] );

		return;
	}

	BRUSH_PRESSURE = wacom && wacom.isWacom ? wacom.pressure : 1;

	var pos = screenToCanvas(event.clientX, event.clientY);
	isDrawing = true;
	brush.strokeStart( pos.x, pos.y );

	var symPoints = getSymmetryPoints(pos.x, pos.y);
	for (var si = 0; si < symmetryBrushes.length; si++)
	{
		symmetryBrushes[si].strokeStart( symPoints[si].x, symPoints[si].y );
	}

	window.addEventListener('mousemove', onCanvasMouseMove, { passive: false });
	window.addEventListener('mouseup', onCanvasMouseUp, { passive: false });
}

function onCanvasMouseMove( event )
{
	BRUSH_PRESSURE = wacom && wacom.isWacom ? wacom.pressure : 1;

	var pos = screenToCanvas(event.clientX, event.clientY);
	brush.stroke( pos.x, pos.y );

	var symPoints = getSymmetryPoints(pos.x, pos.y);
	for (var si = 0; si < symmetryBrushes.length; si++)
	{
		symmetryBrushes[si].stroke( symPoints[si].x, symPoints[si].y );
	}
}

function onCanvasMouseUp()
{
	brush.strokeEnd();

	for (var si = 0; si < symmetryBrushes.length; si++)
	{
		symmetryBrushes[si].strokeEnd();
	}

	window.removeEventListener('mousemove', onCanvasMouseMove, { passive: false });
	window.removeEventListener('mouseup', onCanvasMouseUp, { passive: false });

	if (isDrawing)
	{
		isDrawing = false;
		saveToHistory();
	}

	if (STORAGE)
	{
		clearTimeout(saveTimeOut);
		saveTimeOut = setTimeout(saveToLocalStorage, 2000, true);
	}
}


//

function getTouchDistance(t1, t2)
{
	var dx = t1.pageX - t2.pageX;
	var dy = t1.pageY - t2.pageY;
	return Math.sqrt(dx * dx + dy * dy);
}

function onCanvasTouchStart( event )
{
	cleanPopUps();

	if(event.touches.length == 2)
	{
		event.preventDefault();
		multiTouchFingers = 2;
		isPinching = false;
		pinchStartDist = getTouchDistance(event.touches[0], event.touches[1]);
		pinchStartZoom = zoomLevel;
		lastPinchCenterX = (event.touches[0].pageX + event.touches[1].pageX) / 2;
		lastPinchCenterY = (event.touches[0].pageY + event.touches[1].pageY) / 2;

		if (isDrawing)
		{
			brush.strokeEnd();
			isDrawing = false;
		}

		window.addEventListener('touchmove', onCanvasTouchMove, { passive: false });
		window.addEventListener('touchend', onCanvasTouchEnd, { passive: false });
		return;
	}

	if(event.touches.length == 3)
	{
		event.preventDefault();
		multiTouchFingers = 3;
		return;
	}

	if(event.touches.length == 1)
	{
		event.preventDefault();

		multiTouchFingers = 0;
		isDrawing = true;
		var pos = screenToCanvas(event.touches[0].pageX, event.touches[0].pageY);
		brush.strokeStart( pos.x, pos.y );

		var symPoints = getSymmetryPoints(pos.x, pos.y);
		for (var si = 0; si < symmetryBrushes.length; si++)
		{
			symmetryBrushes[si].strokeStart( symPoints[si].x, symPoints[si].y );
		}

		window.addEventListener('touchmove', onCanvasTouchMove, { passive: false });
		window.addEventListener('touchend', onCanvasTouchEnd, { passive: false });
	}
}

function onCanvasTouchMove( event )
{
	if(event.touches.length == 2)
	{
		event.preventDefault();
		var dist = getTouchDistance(event.touches[0], event.touches[1]);
		var distChange = Math.abs(dist - pinchStartDist);

		if (distChange > 10)
		{
			isPinching = true;
		}

		if (isPinching)
		{
			var centerX = (event.touches[0].pageX + event.touches[1].pageX) / 2;
			var centerY = (event.touches[0].pageY + event.touches[1].pageY) / 2;

			var newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, pinchStartZoom * (dist / pinchStartDist)));

			// Zoom toward pinch center
			panX = centerX - (centerX - panX) * (newZoom / zoomLevel);
			panY = centerY - (centerY - panY) * (newZoom / zoomLevel);
			zoomLevel = newZoom;

			// Also allow panning by moving the pinch center
			panX += centerX - lastPinchCenterX;
			panY += centerY - lastPinchCenterY;

			lastPinchCenterX = centerX;
			lastPinchCenterY = centerY;

			clampPan();
			applyZoomTransform();
		}

		return;
	}

	if(event.touches.length == 1 && isDrawing)
	{
		event.preventDefault();
		var pos = screenToCanvas(event.touches[0].pageX, event.touches[0].pageY);
		brush.stroke( pos.x, pos.y );

		var symPoints = getSymmetryPoints(pos.x, pos.y);
		for (var si = 0; si < symmetryBrushes.length; si++)
		{
			symmetryBrushes[si].stroke( symPoints[si].x, symPoints[si].y );
		}
	}
}

function onCanvasTouchEnd( event )
{
	if(event.touches.length == 0)
	{
		event.preventDefault();

		if (multiTouchFingers == 2 && !isPinching)
		{
			multiTouchFingers = 0;
			onMenuUndo();
			window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
			window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });
			return;
		}

		if (multiTouchFingers == 2 && isPinching)
		{
			multiTouchFingers = 0;
			isPinching = false;
			window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
			window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });
			return;
		}

		if (multiTouchFingers == 3)
		{
			multiTouchFingers = 0;
			onMenuRedo();
			window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
			window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });
			return;
		}

		brush.strokeEnd();

		for (var si = 0; si < symmetryBrushes.length; si++)
		{
			symmetryBrushes[si].strokeEnd();
		}

		window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
		window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });

		isDrawing = false;
		saveToHistory();
	}
}

function onCanvasWheel( event )
{
	if (event.ctrlKey)
	{
		event.preventDefault();

		var delta = -event.deltaY * 0.01;
		var newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, zoomLevel + delta));

		// Zoom toward cursor position
		panX = event.clientX - (event.clientX - panX) * (newZoom / zoomLevel);
		panY = event.clientY - (event.clientY - panY) * (newZoom / zoomLevel);
		zoomLevel = newZoom;

		clampPan();
		applyZoomTransform();
	}
}

function onMenuZoomReset()
{
	zoomLevel = 1;
	panX = 0;
	panY = 0;
	applyZoomTransform();
}

//

function saveToHistory()
{
	undoHistory = undoHistory.slice(0, historyIndex + 1);
	undoHistory.push(context.getImageData(0, 0, canvas.width, canvas.height));

	if (undoHistory.length > HISTORY_MAX)
		undoHistory.splice(0, undoHistory.length - HISTORY_MAX);

	historyIndex = undoHistory.length - 1;
}

function onMenuUndo()
{
	if (historyIndex <= 0)
		return;

	historyIndex--;
	context.putImageData(undoHistory[historyIndex], 0, 0);
	saveToLocalStorage();
}

function onMenuRedo()
{
	if (historyIndex >= undoHistory.length - 1)
		return;

	historyIndex++;
	context.putImageData(undoHistory[historyIndex], 0, 0);
	saveToLocalStorage();
}

function saveToLocalStorage()
{
	localStorage['harmony-canvas'] = canvas.toDataURL('image/png');
}

function flatten()
{
	var context = flattenCanvas.getContext("2d");

	context.fillStyle = 'rgb(' + BACKGROUND_COLOR[0] + ', ' + BACKGROUND_COLOR[1] + ', ' + BACKGROUND_COLOR[2] + ')';
	context.fillRect(0, 0, canvas.width, canvas.height);
	context.drawImage(canvas, 0, 0);
}

function cleanPopUps()
{
	if (isFgColorSelectorVisible)
	{
		foregroundColorSelector.hide();
		isFgColorSelectorVisible = false;
	}

	if (isBgColorSelectorVisible)
	{
		backgroundColorSelector.hide();
		isBgColorSelectorVisible = false;
	}

	if (isAboutVisible)
	{
		about.hide();
		isAboutVisible = false;
	}
}

		</script>
	</body>
</html>
