<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>Harmony</title>
		<meta charset="utf-8"/>
		<meta name="description" content="Procedural Drawing Tool"/>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
		<style type="text/css">
			*
			{
				color: #444;
				font-family: Monospace;
				font-size: 12px;
			}

			body
			{
				margin: 0px;
				overflow: hidden;
			}

			select
			{
				text-transform: uppercase;
				font-size: 11px;
				text-align: center;
			}

			hr
			{
				border: 0;
				height: 1px;
				background-color: #ccc;
				margin: 20px 0px;
			}

			.gui
			{
				color: #ccc;
				background-color: #fff;
				border-bottom: 1px solid #ddd;
				padding: 5px 10px;
				text-align: center;
				text-transform: uppercase;
				line-height: 18px;
				cursor: default;
			}

			.button
			{
				padding: 2px;
				cursor: pointer;
			}

			.button.rec-active
			{
				color: #f44;
			}

			.key
			{
				padding: 0px 8px;
				margin-left: 1px;
				background-color: #eee;
			}

			.gui.collapsed > *:not(.collapse-btn):not(.drag-handle):not(.brush-selector) {
				display: none !important;
			}
			.gui.collapsed {
				padding: 5px;
				min-width: 0;
				width: auto;
			}
			.collapse-btn {
				padding: 2px 6px;
				cursor: pointer;
				font-size: 14px;
				color: #888;
				user-select: none;
				border: none;
				background: none;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">

// brushes/circles.js

function circles( context )
{
	this.init( context );
}

circles.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d, cx, cy, steps, step_delta;

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		dx = mouseX - this.prevMouseX;
		dy = mouseY - this.prevMouseY;
		d = Math.sqrt(dx * dx + dy * dy) * 2;

		cx = Math.floor(mouseX / 100) * 100 + 50;
		cy = Math.floor(mouseY / 100) * 100 + 50;

		steps = Math.floor( Math.random() * 10 );
		step_delta = d / steps;

		for (i = 0; i < steps; i++)
		{
			this.context.beginPath();
			this.context.arc( cx, cy, (steps - i) * step_delta, 0, Math.PI*2, true);
			this.context.stroke();
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/chrome.js

function chrome( context )
{
	this.init( context );
}

chrome.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;

		if (RegExp(" AppleWebKit/").test(navigator.userAgent))
			this.context.globalCompositeOperation = 'darker';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";
		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 1000)
			{
				this.context.strokeStyle = "rgba(" + Math.floor(Math.random() * COLOR[0]) + ", " + Math.floor(Math.random() * COLOR[1]) + ", " + Math.floor(Math.random() * COLOR[2]) + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + " )";
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0] + (dx * 0.2), this.points[this.count][1] + (dy * 0.2));
				this.context.lineTo( this.points[i][0] - (dx * 0.2), this.points[i][1] - (dy * 0.2));
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/fur.js

function fur( context )
{
	this.init( context );
}

fur.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 2000 && Math.random() > d / 2000)
			{
				this.context.beginPath();
				this.context.moveTo( mouseX + (dx * 0.5), mouseY + (dy * 0.5));
				this.context.lineTo( mouseX - (dx * 0.5), mouseY - (dy * 0.5));
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/grid.js

function grid( context )
{
	this.init( context );
}

grid.prototype =
{
	context: null,

	init: function( context )
	{
		this.context = context;

		if (RegExp(" AppleWebKit/").test(navigator.userAgent))
			this.context.globalCompositeOperation = 'darker';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
	},

	stroke: function( mouseX, mouseY )
	{
		var i, cx, cy, dx, dy;

		cx = Math.round(mouseX / 100) * 100;
		cy = Math.round(mouseY / 100) * 100;

		dx = (cx - mouseX) * 10;
		dy = (cy - mouseY) * 10;

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.01 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		for (i = 0; i < 50; i++)
		{
			this.context.beginPath();
			this.context.moveTo( cx, cy );
			this.context.quadraticCurveTo(mouseX + Math.random() * dx, mouseY + Math.random() * dy, cx, cy);
			this.context.stroke();
		}
	},

	strokeEnd: function()
	{

	}
}

// brushes/longfur.js

function longfur( context )
{
	this.init( context );
}

longfur.prototype =
{
	context: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
	},

	stroke: function( mouseX, mouseY )
	{
		var i, size, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.05 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		for (i = 0; i < this.points.length; i++)
		{
			size = -Math.random();
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 4000 && Math.random() > d / 4000)
			{
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0] + (dx * size), this.points[this.count][1] + (dy * size));
				this.context.lineTo( this.points[i][0] - (dx * size) + Math.random() * 2, this.points[i][1] - (dy * size) + Math.random() * 2);
				this.context.stroke();
			}
		}

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/ribbon.js

function ribbon( context )
{
	this.init( context );
}

ribbon.prototype =
{
	context: null,

	mouseX: null, mouseY: null,

	painters: null,

	interval: null,

	init: function( context )
	{
		var scope = this;

		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.mouseX = SCREEN_WIDTH / 2;
		this.mouseY = SCREEN_HEIGHT / 2;

		this.painters = new Array();

		for (var i = 0; i < 50; i++)
		{
			this.painters.push({ dx: SCREEN_WIDTH / 2, dy: SCREEN_HEIGHT / 2, ax: 0, ay: 0, div: 0.1, ease: Math.random() * 0.2 + 0.6 });
		}

		this.interval = setInterval( update, 1000/60 );

		function update()
		{
			var i;

			this.context.lineWidth = BRUSH_SIZE;
			this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.05 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

			for (i = 0; i < scope.painters.length; i++)
			{
				scope.context.beginPath();
				scope.context.moveTo(scope.painters[i].dx, scope.painters[i].dy);

				scope.painters[i].dx -= scope.painters[i].ax = (scope.painters[i].ax + (scope.painters[i].dx - scope.mouseX) * scope.painters[i].div) * scope.painters[i].ease;
				scope.painters[i].dy -= scope.painters[i].ay = (scope.painters[i].ay + (scope.painters[i].dy - scope.mouseY) * scope.painters[i].div) * scope.painters[i].ease;
				scope.context.lineTo(scope.painters[i].dx, scope.painters[i].dy);
				scope.context.stroke();
			}
		}
	},

	destroy: function()
	{
		clearInterval(this.interval);
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.mouseX = mouseX;
		this.mouseY = mouseY

		for (var i = 0; i < this.painters.length; i++)
		{
			this.painters[i].dx = mouseX;
			this.painters[i].dy = mouseY;
		}

		this.shouldDraw = true;
	},

	stroke: function( mouseX, mouseY )
	{
		this.mouseX = mouseX;
		this.mouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/shaded.js

function shaded( context )
{
	this.init( context );
}

shaded.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 1000)
			{
				this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + ((1 - (d / 1000)) * 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY) + " )";

				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0], this.points[this.count][1]);
				this.context.lineTo( this.points[i][0], this.points[i][1]);
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/simple.js

function simple( context )
{
	this.init( context );
}

simple.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.5 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/sketchy.js

function sketchy( context )
{
	this.init( context );
}

sketchy.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.05 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 4000 && Math.random() > (d / 2000))
			{
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0] + (dx * 0.3), this.points[this.count][1] + (dy * 0.3));
				this.context.lineTo( this.points[i][0] - (dx * 0.3), this.points[i][1] - (dy * 0.3));
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/squares.js

function squares( context )
{
	this.init( context );
}

squares.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var dx, dy, angle, px, py;

		dx = mouseX - this.prevMouseX;
		dy = mouseY - this.prevMouseY;
		angle = 1.57079633;
		px = Math.cos(angle) * dx - Math.sin(angle) * dy;
		py = Math.sin(angle) * dx + Math.cos(angle) * dy;

		this.context.lineWidth = BRUSH_SIZE;
		this.context.fillStyle = "rgba(" + BACKGROUND_COLOR[0] + ", " + BACKGROUND_COLOR[1] + ", " + BACKGROUND_COLOR[2] + ", " + BRUSH_PRESSURE * BRUSH_OPACITY + ")";
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX - px, this.prevMouseY - py);
		this.context.lineTo(this.prevMouseX + px, this.prevMouseY + py);
		this.context.lineTo(mouseX + px, mouseY + py);
		this.context.lineTo(mouseX - px, mouseY - py);
		this.context.lineTo(this.prevMouseX - px, this.prevMouseY - py);
		this.context.fill();
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/web.js

function web( context )
{
	this.init( context );
}

web.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	points: null, count: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';

		this.points = new Array();
		this.count = 0;
	},

	destroy: function()
	{
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var i, dx, dy, d;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.5 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";
		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		this.context.strokeStyle = "rgba(" + COLOR[0] + ", " + COLOR[1] + ", " + COLOR[2] + ", " + 0.1 * BRUSH_PRESSURE * BRUSH_OPACITY + ")";

		for (i = 0; i < this.points.length; i++)
		{
			dx = this.points[i][0] - this.points[this.count][0];
			dy = this.points[i][1] - this.points[this.count][1];
			d = dx * dx + dy * dy;

			if (d < 2500 && Math.random() > 0.9)
			{
				this.context.beginPath();
				this.context.moveTo( this.points[this.count][0], this.points[this.count][1]);
				this.context.lineTo( this.points[i][0], this.points[i][1]);
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;

		this.count ++;
	},

	strokeEnd: function()
	{

	}
}

// brushes/eraser.js

function eraser( context )
{
	this.init( context );
}

eraser.prototype =
{
	context: null,

	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'destination-out';
	},

	destroy: function()
	{
		this.context.globalCompositeOperation = 'source-over';
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		this.context.lineWidth = BRUSH_SIZE;
		this.context.strokeStyle = "rgba(0, 0, 0, 1)";

		this.context.beginPath();
		this.context.moveTo(this.prevMouseX, this.prevMouseY);
		this.context.lineTo(mouseX, mouseY);
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function()
	{

	}
}

// brushes/neon.js

function neon( context )
{
	this.init( context );
}

neon.prototype =
{
	context: null,
	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var pressureScale = 0.5 + BRUSH_PRESSURE * 0.5;

		this.context.lineCap = 'round';

		// Outer glow
		this.context.lineWidth = BRUSH_SIZE * 8 * pressureScale;
		this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.02 * p ) + ")";
		this.context.beginPath();
		this.context.moveTo( this.prevMouseX, this.prevMouseY );
		this.context.lineTo( mouseX, mouseY );
		this.context.stroke();

		// Mid glow
		this.context.lineWidth = BRUSH_SIZE * 4 * pressureScale;
		this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.05 * p ) + ")";
		this.context.beginPath();
		this.context.moveTo( this.prevMouseX, this.prevMouseY );
		this.context.lineTo( mouseX, mouseY );
		this.context.stroke();

		// Bright core — width and color brightness scale with pressure
		var coreBoost = Math.round( 100 * BRUSH_PRESSURE );
		this.context.lineWidth = Math.max( 1, BRUSH_SIZE * 0.5 * pressureScale );
		this.context.strokeStyle = "rgba(" + Math.min( 255, r + coreBoost ) + "," + Math.min( 255, g + coreBoost ) + "," + Math.min( 255, b + coreBoost ) + "," + ( 0.9 * p ) + ")";
		this.context.beginPath();
		this.context.moveTo( this.prevMouseX, this.prevMouseY );
		this.context.lineTo( mouseX, mouseY );
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function() {}
}

// brushes/watercolor.js

function watercolor( context )
{
	this.init( context );
}

watercolor.prototype =
{
	context: null,
	prevMouseX: null, prevMouseY: null,
	points: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
		this.points = [];
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var i, ox, oy;

		this.points.push( [ mouseX, mouseY ] );

		this.context.lineCap = 'round';

		var passes    = Math.round( 5 + BRUSH_PRESSURE * 5 );
		var bleedMult = 0.5 + BRUSH_PRESSURE * 0.5;

		// Multiple overlapping offset passes for soft bleed
		for ( i = 0; i < passes; i++ )
		{
			ox = ( Math.random() - 0.5 ) * BRUSH_SIZE * 1.5 * bleedMult;
			oy = ( Math.random() - 0.5 ) * BRUSH_SIZE * 1.5 * bleedMult;

			this.context.lineWidth = BRUSH_SIZE * ( 0.5 + Math.random() * 0.5 );
			this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.015 * p ) + ")";
			this.context.beginPath();
			this.context.moveTo( this.prevMouseX + ox, this.prevMouseY + oy );
			this.context.lineTo( mouseX + ox, mouseY + oy );
			this.context.stroke();
		}

		// Occasional bleed toward a history point
		if ( this.points.length > 5 && Math.random() < 0.3 )
		{
			var idx = Math.floor( Math.random() * this.points.length );
			var dx = this.points[ idx ][ 0 ] - mouseX;
			var dy = this.points[ idx ][ 1 ] - mouseY;

			if ( dx * dx + dy * dy < BRUSH_SIZE * BRUSH_SIZE * 16 * bleedMult * bleedMult )
			{
				this.context.lineWidth = BRUSH_SIZE * 0.5;
				this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.008 * p ) + ")";
				this.context.beginPath();
				this.context.moveTo( mouseX, mouseY );
				this.context.lineTo( mouseX + dx * 0.5, mouseY + dy * 0.5 );
				this.context.stroke();
			}
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function() {}
}

// brushes/splatter.js

function splatter( context )
{
	this.init( context );
}

splatter.prototype =
{
	context: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY ) {},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var pressureScale = 0.5 + BRUSH_PRESSURE * 0.5;
		var count  = Math.max( 1, Math.round( ( Math.floor( BRUSH_SIZE * 1.5 ) + 5 ) * pressureScale ) );
		var radius = BRUSH_SIZE * 3 * pressureScale;
		var i, angle, dist, x, y, dotSize;

		for ( i = 0; i < count; i++ )
		{
			angle = Math.random() * Math.PI * 2;
			dist = Math.random() * radius;
			x = mouseX + Math.cos( angle ) * dist;
			y = mouseY + Math.sin( angle ) * dist;
			dotSize = Math.random() * BRUSH_SIZE * 0.4 + 0.5;

			this.context.beginPath();
			this.context.arc( x, y, dotSize, 0, Math.PI * 2, false );
			this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + ( Math.random() * 0.5 * p ) + ")";
			this.context.fill();
		}
	},

	strokeEnd: function() {}
}

// brushes/calligraphy.js

function calligraphy( context )
{
	this.init( context );
}

calligraphy.prototype =
{
	context: null,
	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var dx = mouseX - this.prevMouseX;
		var dy = mouseY - this.prevMouseY;
		var angle = Math.atan2( dy, dx );

		// Dynamic nib angle from pen tilt (falls back to 45° for mouse/touch)
		var nibAngle = ( BRUSH_TILT_X === 0 && BRUSH_TILT_Y === 0 )
			? Math.PI / 4
			: Math.atan2( BRUSH_TILT_Y, BRUSH_TILT_X );

		// Width = perpendicular projection of nib relative to stroke direction, scaled by pressure
		var width = ( Math.abs( Math.cos( angle - nibAngle ) ) * BRUSH_SIZE + 1 )
			* ( 0.5 + BRUSH_PRESSURE * 0.5 );

		this.context.lineWidth = width;
		this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.9 * p ) + ")";
		this.context.lineCap = 'butt';
		this.context.beginPath();
		this.context.moveTo( this.prevMouseX, this.prevMouseY );
		this.context.lineTo( mouseX, mouseY );
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function() {}
}

// brushes/smoke.js

function smoke( context )
{
	this.init( context );
}

smoke.prototype =
{
	context: null,
	mouseX: null, mouseY: null,
	particles: null,
	interval: null,
	isDrawing: false,

	init: function( context )
	{
		var scope = this;
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
		this.particles = [];
		this.mouseX = SCREEN_WIDTH / 2;
		this.mouseY = SCREEN_HEIGHT / 2;
		this.isDrawing = false;

		this.interval = setInterval( function() { scope.update(); }, 1000 / 60 );
	},

	update: function()
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var i, p;

		if ( this.isDrawing )
		{
			var particleCount = Math.round( 1 + BRUSH_PRESSURE * 5 );
			var tiltDriftX    = ( BRUSH_TILT_X / 90 ) * 1.5;
			var tiltDriftY    = ( BRUSH_TILT_Y / 90 ) * 1.5;

			for ( var j = 0; j < particleCount; j++ )
			{
				this.particles.push({
					x: this.mouseX + ( Math.random() - 0.5 ) * BRUSH_SIZE,
					y: this.mouseY + ( Math.random() - 0.5 ) * BRUSH_SIZE,
					vx: ( Math.random() - 0.5 ) * 0.5 + tiltDriftX,
					vy: -( Math.random() * 1.5 + 0.5 ) + tiltDriftY,
					radius: Math.random() * BRUSH_SIZE * 0.5 + BRUSH_SIZE * 0.2,
					alpha: Math.random() * 0.3 * BRUSH_PRESSURE * BRUSH_OPACITY
				});
			}
		}

		for ( i = this.particles.length - 1; i >= 0; i-- )
		{
			p = this.particles[ i ];
			p.x += p.vx;
			p.y += p.vy;
			p.vx += ( Math.random() - 0.5 ) * 0.2;
			p.radius *= 1.01;
			p.alpha *= 0.97;

			if ( p.alpha < 0.002 )
			{
				this.particles.splice( i, 1 );
				continue;
			}

			this.context.beginPath();
			this.context.arc( p.x, p.y, p.radius, 0, Math.PI * 2, false );
			this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + p.alpha + ")";
			this.context.fill();
		}
	},

	destroy: function()
	{
		clearInterval( this.interval );
	},

	strokeStart: function( mouseX, mouseY )
	{
		this.mouseX = mouseX;
		this.mouseY = mouseY;
		this.isDrawing = true;
	},

	stroke: function( mouseX, mouseY )
	{
		this.mouseX = mouseX;
		this.mouseY = mouseY;
	},

	strokeEnd: function()
	{
		this.isDrawing = false;
	}
}

// brushes/stipple.js

function stipple( context )
{
	this.init( context );
}

stipple.prototype =
{
	context: null,
	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var pressureScale = 0.5 + BRUSH_PRESSURE * 0.5;
		var count = Math.max( 1, Math.round( ( Math.floor( BRUSH_SIZE * 0.8 ) + 3 ) * pressureScale ) );
		var spread = BRUSH_SIZE * 0.8;
		var i, x, y, dr, dg, db;

		for ( i = 0; i < count; i++ )
		{
			x = mouseX + ( Math.random() - 0.5 ) * spread * 2;
			y = mouseY + ( Math.random() - 0.5 ) * spread * 2;

			// Slight color variation for pointillist feel
			dr = Math.min( 255, Math.max( 0, r + Math.floor( ( Math.random() - 0.5 ) * 30 ) ) );
			dg = Math.min( 255, Math.max( 0, g + Math.floor( ( Math.random() - 0.5 ) * 30 ) ) );
			db = Math.min( 255, Math.max( 0, b + Math.floor( ( Math.random() - 0.5 ) * 30 ) ) );

			var dotR = Math.max( 0.3, ( Math.random() * 1.5 + 0.5 ) * pressureScale );
			this.context.beginPath();
			this.context.arc( x, y, dotR, 0, Math.PI * 2, false );
			this.context.fillStyle = "rgba(" + dr + "," + dg + "," + db + "," + ( 0.6 * p * Math.random() ) + ")";
			this.context.fill();
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function() {}
}

// brushes/lightning.js

function lightning( context )
{
	this.init( context );
}

lightning.prototype =
{
	context: null,
	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var pressureScale = 0.5 + BRUSH_PRESSURE * 0.5;
		var dispMult      = 0.25 + BRUSH_PRESSURE * 0.75;
		var segments = 6;
		var dx = mouseX - this.prevMouseX;
		var dy = mouseY - this.prevMouseY;
		var len = Math.sqrt( dx * dx + dy * dy ) || 1;
		var nx = -dy / len, ny = dx / len; // unit perpendicular
		var i, pts = [ [ this.prevMouseX, this.prevMouseY ] ];

		for ( i = 1; i < segments; i++ )
		{
			var t = i / segments;
			var disp = ( Math.random() - 0.5 ) * BRUSH_SIZE * 3 * dispMult;
			pts.push( [
				this.prevMouseX + dx * t + nx * disp,
				this.prevMouseY + dy * t + ny * disp
			] );
		}
		pts.push( [ mouseX, mouseY ] );

		// Outer glow
		this.context.lineWidth = BRUSH_SIZE * 1.5 * pressureScale;
		this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.04 * p ) + ")";
		this.context.lineCap = 'round';
		this.context.beginPath();
		this.context.moveTo( pts[ 0 ][ 0 ], pts[ 0 ][ 1 ] );
		for ( i = 1; i < pts.length; i++ ) this.context.lineTo( pts[ i ][ 0 ], pts[ i ][ 1 ] );
		this.context.stroke();

		// Jagged bolt
		this.context.lineWidth = Math.max( 0.5, BRUSH_SIZE * 0.2 * pressureScale );
		this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( 0.85 * p ) + ")";
		this.context.beginPath();
		this.context.moveTo( pts[ 0 ][ 0 ], pts[ 0 ][ 1 ] );
		for ( i = 1; i < pts.length; i++ ) this.context.lineTo( pts[ i ][ 0 ], pts[ i ][ 1 ] );
		this.context.stroke();

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function() {}
}

// brushes/chalk.js

function chalk( context )
{
	this.init( context );
}

chalk.prototype =
{
	context: null,
	prevMouseX: null, prevMouseY: null,

	init: function( context )
	{
		this.context = context;
		this.context.globalCompositeOperation = 'source-over';
	},

	destroy: function() {},

	strokeStart: function( mouseX, mouseY )
	{
		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	stroke: function( mouseX, mouseY )
	{
		var r = COLOR[0], g = COLOR[1], b = COLOR[2];
		var p = BRUSH_PRESSURE * BRUSH_OPACITY;
		var i, ox, oy, t;

		// Harder pressure = denser chalk (fewer gaps)
		var gapProb = 0.5 - BRUSH_PRESSURE * 0.25;

		// Tilt: grain aligns with pen lean when tilt > 5°
		var tiltMag    = Math.sqrt( BRUSH_TILT_X * BRUSH_TILT_X + BRUSH_TILT_Y * BRUSH_TILT_Y );
		var grainAngle = ( tiltMag > 5 ) ? Math.atan2( BRUSH_TILT_Y, BRUSH_TILT_X ) : null;

		this.context.lineCap = 'round';

		// Multiple thin passes with random offsets and gaps (chalk grain)
		for ( i = 0; i < 5; i++ )
		{
			if ( Math.random() < gapProb ) continue; // gap = rough texture

			if ( grainAngle !== null ) {
				var d = Math.random() * BRUSH_SIZE * 0.8;
				ox = Math.cos( grainAngle ) * d;
				oy = Math.sin( grainAngle ) * d;
			} else {
				ox = ( Math.random() - 0.5 ) * BRUSH_SIZE * 0.8;
				oy = ( Math.random() - 0.5 ) * BRUSH_SIZE * 0.8;
			}

			this.context.lineWidth = ( Math.random() * BRUSH_SIZE * 0.4 + 0.5 ) * ( 0.7 + BRUSH_PRESSURE * 0.3 );
			this.context.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + ( Math.random() * 0.25 * p ) + ")";
			this.context.beginPath();
			this.context.moveTo( this.prevMouseX + ox, this.prevMouseY + oy );
			this.context.lineTo( mouseX + ox, mouseY + oy );
			this.context.stroke();
		}

		// Sparse grain dots along the stroke
		var dotCount = Math.floor( BRUSH_SIZE * 0.5 * ( 0.5 + BRUSH_PRESSURE * 0.5 ) );
		for ( i = 0; i < dotCount; i++ )
		{
			t = Math.random();
			ox = ( Math.random() - 0.5 ) * BRUSH_SIZE;
			oy = ( Math.random() - 0.5 ) * BRUSH_SIZE;

			this.context.beginPath();
			this.context.arc(
				this.prevMouseX + ( mouseX - this.prevMouseX ) * t + ox,
				this.prevMouseY + ( mouseY - this.prevMouseY ) * t + oy,
				Math.random() * 0.8 + 0.3, 0, Math.PI * 2, false
			);
			this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + ( Math.random() * 0.3 * p ) + ")";
			this.context.fill();
		}

		this.prevMouseX = mouseX;
		this.prevMouseY = mouseY;
	},

	strokeEnd: function() {}
}

// colorutils.js

function HSB2RGB(hue, sat, val)
{
	var red, green, blue,
	i, f, p, q, t;

	if (val == 0)
		return [ 0, 0, 0 ];

	hue *= 0.016666667; // /= 60;
	sat *= 0.01; // /= 100;
	val *= 0.01; // /= 100;

	i = Math.floor(hue);
	f = hue - i;
	p = val * (1 - sat);
	q = val * (1 - (sat * f));
	t = val * (1 - (sat * (1 - f)));

	switch(i)
	{
		case 0: red = val; green = t; blue = p; break;
		case 1: red = q; green = val; blue = p; break;
		case 2: red = p; green = val; blue = t; break;
		case 3: red = p; green = q; blue = val; break;
		case 4: red = t; green = p; blue = val; break;
		case 5: red = val; green = p; blue = q; break;
	}

	return [red, green, blue];
}

function RGB2HSB(red, green, blue)
{
	var x, f, i, hue, sat, val;

	x = Math.min( Math.min( red, green ), blue );
	val = Math.max( Math.max( red, green ), blue );

	if (x==val)
		return [0, 0, val*100];

	f = (red == x) ? green - blue : ((green == x) ? blue - red : red - green);
	i = (red == x) ? 3 : ((green == x) ? 5 : 1);

	hue = Math.floor((i - f / (val - x)) * 60) % 360;
	sat = Math.floor(((val - x) / val) * 100);
	val = Math.floor(val * 100);

	return [hue, sat, val];
}

// colorselector.js

function ColorSelector( gradient )
{
	this.init( gradient );
}

ColorSelector.prototype =
{
	container: null,
	color: [0, 0, 0],

	hueSelector: null,
	luminosity: null,
	luminosityData: null,
	luminositySelector: null,
	luminosityPosition: null,

	dispatcher: null,
	changeEvent: null,

	init: function( gradient )
	{
		const DPR = Math.round( window.devicePixelRatio );

		var scope = this, context, hue, hueData;

		this.container = document.createElement('div');
		this.container.style.position = 'absolute';
		this.container.style.width = '250px';
		this.container.style.height = '250px';
		this.container.style.visibility = 'hidden';
		this.container.style.cursor = 'pointer';
		this.container.style.clipPath = 'circle(50.0% at 50% 50%)';
		this.container.addEventListener('pointerdown', function(e) { e.stopPropagation(); }, false);
		this.container.addEventListener('mousedown', onMouseDown, false);
		this.container.addEventListener('touchstart', onTouchStart, false);

		hue = document.createElement("canvas");
		hue.width = 250 * DPR;
		hue.height = 250 * DPR;
		hue.style.width = '250px';
		hue.style.height = '250px';

		context = hue.getContext("2d");
		context.drawImage(gradient, 0, 0, hue.width, hue.height);

		hueData = context.getImageData(0, 0, hue.width, hue.height).data;

		this.container.appendChild(hue);

		this.luminosity = document.createElement("canvas");
		this.luminosity.style.position = 'absolute';
		this.luminosity.style.left = '0px';
		this.luminosity.style.top = '0px';
		this.luminosity.width = 250 * DPR;
		this.luminosity.height = 250 * DPR;
		this.luminosity.style.width = '250px';
		this.luminosity.style.height = '250px';

		context = this.luminosity.getContext("2d");
		context.scale(DPR, DPR);
		context.translate(250 / 2, 250 / 2);

		this.container.appendChild(this.luminosity);

		this.hueSelector = document.createElement("canvas");
		this.hueSelector.style.position = 'absolute';
		this.hueSelector.style.left = ((hue.width - 15) / 2 ) + 'px';
		this.hueSelector.style.top = ((hue.height - 15) / 2 ) + 'px';
		this.hueSelector.width = 15 * DPR;
		this.hueSelector.height = 15 * DPR;
		this.hueSelector.style.width = '15px';
		this.hueSelector.style.height = '15px';

		context = this.hueSelector.getContext("2d");
		context.scale(DPR, DPR);
		context.lineWidth = 2;
		context.strokeStyle = "rgba(0, 0, 0, 0.5)";
		context.beginPath();
		context.arc(8, 8, 6, 0, Math.PI * 2, true);
		context.stroke();
		context.strokeStyle = "rgba(256, 256, 256, 0.8)";
		context.beginPath();
		context.arc(7, 7, 6, 0, Math.PI * 2, true);
		context.stroke();

		this.container.appendChild( this.hueSelector );

		this.luminosityPosition = [ (gradient.width - 15), (gradient.height - 15) / 2 ];

		this.luminositySelector = document.createElement("canvas");
		this.luminositySelector.style.position = 'absolute';
		this.luminositySelector.style.left = (this.luminosityPosition[0] - 7) + 'px';
		this.luminositySelector.style.top = (this.luminosityPosition[1] - 7) + 'px';
		this.luminositySelector.width = 15 * DPR;
		this.luminositySelector.height = 15 * DPR;
		this.luminositySelector.style.width = '15px';
		this.luminositySelector.style.height = '15px';

		context = this.luminositySelector.getContext("2d");
		context.drawImage(this.hueSelector, 0, 0, this.luminositySelector.width, this.luminositySelector.height);

		this.container.appendChild(this.luminositySelector);

		this.dispatcher = document.createElement('div'); // this could be better handled...

		this.changeEvent = document.createEvent('Events');
		this.changeEvent.initEvent('change', true, true);

		//

		function onMouseDown( event )
		{
			window.addEventListener('mousemove', onMouseMove, false);
			window.addEventListener('mouseup', onMouseUp, false);

			update( event.clientX - scope.container.offsetLeft, event.clientY - scope.container.offsetTop );
		}

		function onMouseMove( event )
		{
			update( event.clientX - scope.container.offsetLeft, event.clientY - scope.container.offsetTop );
		}

		function onMouseUp( event )
		{
			window.removeEventListener('mousemove', onMouseMove, false);
			window.removeEventListener('mouseup', onMouseUp, false);
		}

		function onTouchStart( event )
		{
			if(event.touches.length == 1)
			{
				event.preventDefault();

				window.addEventListener('touchmove', onTouchMove, false);
				window.addEventListener('touchend', onTouchEnd, false);

				update( event.touches[0].pageX - scope.container.offsetLeft, event.touches[0].pageY - scope.container.offsetTop );
			}
		}

		function onTouchMove( event )
		{
			if(event.touches.length == 1)
			{
				event.preventDefault();

				update( event.touches[0].pageX - scope.container.offsetLeft, event.touches[0].pageY - scope.container.offsetTop );
			}
		}

		function onTouchEnd( event )
		{
			if(event.touches.length == 0)
			{
				event.preventDefault();

				window.removeEventListener('touchmove', onTouchMove, false);
				window.removeEventListener('touchend', onTouchEnd, false);
			}
		}

		//

		function update(x, y)
		{
			var dx, dy, d, nx, ny;

			dx = x - 125;
			dy = y - 125;
			d = Math.sqrt( dx * dx + dy * dy );

			if (d < 90)
			{
				scope.hueSelector.style.left = (x - 7) + 'px';
				scope.hueSelector.style.top = (y - 7) + 'px';

				var index = Math.round( (x * DPR) + ((y * DPR) * (250 * DPR)) ) * 4;
				scope.updateLuminosity( hueData[index + 0], hueData[index + 1], hueData[index + 2] );
			}
			else if (d > 100)
			{
				nx = dx / d;
				ny = dy / d;

				scope.luminosityPosition[0] = (nx * 110) + 125;
				scope.luminosityPosition[1] = (ny * 110) + 125;

				scope.luminositySelector.style.left = ( scope.luminosityPosition[0] - 7) + 'px';
				scope.luminositySelector.style.top = ( scope.luminosityPosition[1] - 7) + 'px';
			}

			x = Math.floor(scope.luminosityPosition[0]);
			y = Math.floor(scope.luminosityPosition[1]);

			var index = ((x * DPR) + ((y * DPR) * (250 * DPR))) * 4;
			scope.color[0] = scope.luminosityData[index + 0];
			scope.color[1] = scope.luminosityData[index + 1];
			scope.color[2] = scope.luminosityData[index + 2];

			scope.dispatchEvent( scope.changeEvent );
		}
	},


	//

	show: function()
	{
		this.container.style.visibility = 'visible';
	},

	hide: function()
	{
		this.container.style.visibility = 'hidden';
	},

	getColor: function()
	{
		return this.color;
	},

	setColor: function( color )
	{
		// Ok, this is super dirty. The whole class needs some refactoring, again! :/

		var hsb, angle, distance, rgb, DEG2RAD = Math.PI / 180;

		this.color = color;

		hsb = RGB2HSB(color[0] / 255, color[1] / 255, color[2] / 255);

		angle = hsb[0] * DEG2RAD;
		distance = (hsb[1] / 100) * 90;

		this.hueSelector.style.left = ( ( Math.cos(angle) * distance + 125 ) - 7 ) + 'px';
		this.hueSelector.style.top = ( ( Math.sin(angle) * distance + 125 ) - 7 ) + 'px';

		rgb = HSB2RGB(hsb[0], hsb[1], 100);
		rgb[0] *= 255; rgb[1] *= 255; rgb[2] *= 255;

		this.updateLuminosity( rgb[0], rgb[1], rgb[2] );

		angle = (hsb[2] / 100) * 360 * DEG2RAD;

		this.luminosityPosition[0] = ( Math.cos(angle) * 110 ) + 125;
		this.luminosityPosition[1] = ( Math.sin(angle) * 110 ) + 125;

		this.luminositySelector.style.left = ( this.luminosityPosition[0] - 7 ) + 'px';
		this.luminositySelector.style.top = ( this.luminosityPosition[1] - 7 ) + 'px';

		this.dispatchEvent( this.changeEvent );
	},

	//

	updateLuminosity: function( r, g, b )
	{
		var context, angle, angle_cos, angle_sin, shade, radius = 110,
		i, count = 360, DEG2RAD = Math.PI / 180;

		context = this.luminosity.getContext("2d");
		context.clearRect(0, 0, this.luminosity.width, this.luminosity.height);

		const map = (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2;

		for(i = 0; i < count; i++)
		{
			angle = map( i, 0, count, 5, 355 ) * DEG2RAD;
			angle_cos = Math.cos(angle);
			angle_sin = Math.sin(angle);

			shade = i / count;

			context.fillStyle = "rgb(" + Math.floor( r * shade ) + "," + Math.floor( g * shade ) + "," + Math.floor( b * shade ) + ")";
			context.beginPath();
			context.arc(angle_cos * radius, angle_sin * radius, 10, 0, Math.PI * 2);
			context.fill();

		}

		this.luminosityData = context.getImageData(0, 0, this.luminosity.width, this.luminosity.height).data;
	},

	//

	addEventListener: function( type, listener, useCapture )
	{
		this.dispatcher.addEventListener(type, listener, useCapture);
	},

	dispatchEvent: function( event )
	{
		this.dispatcher.dispatchEvent(event);
	},

	removeEventListener: function( type, listener, useCapture )
	{
		this.dispatcher.removeEventListener(type, listener, useCapture);
	}
}

// palette.js

function Palette()
{
	const DPR = Math.round(window.devicePixelRatio);

	var canvas, context, radius = 90, gradient;

	canvas = document.createElement("canvas");
	canvas.width = 250 * DPR;
	canvas.height = 250 * DPR;

	context = canvas.getContext("2d");
	context.scale(DPR, DPR);

	gradient = context.createConicGradient(0, 125, 125);

	for(hue = 0; hue < 360; hue++)
	{
		gradient.addColorStop(hue / 360, 'hsl(' + hue + ', 100%, 50%)');
	}

	context.beginPath();
	context.arc(125, 125, radius, 0, Math.PI * 2);
	context.fillStyle = gradient;
	context.fill();

	gradient = context.createRadialGradient(125, 125, 0, 125, 125, radius);
	gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
	gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

	context.beginPath();
	context.arc(125, 125, radius, 0, Math.PI * 2);
	context.fillStyle = gradient;
	context.fill();

	return canvas;
}

// menu.js

function Menu()
{
	this.init();
}

Menu.prototype =
{
	container: null,

	foregroundColor: null,
	backgroundColor: null,

	selector: null,
	opacitySlider: null,
	opacityLabel: null,
	symmetrySelector: null,
	save: null,
	download: null,
	gif: null,
	upload: null,
	undo: null,
	redo: null,
	clear: null,
	about: null,
	zoomIndicator: null,
	zoomReset: null,

	isDragged: false,

	init: function()
	{
		var scope = this;
		var option, space, separator, color_width = 15, color_height = 15;

		this.container = document.createElement("div");
		this.container.className = 'gui';
		this.container.style.position = 'absolute';
		this.container.style.top = '0px';

		// Collapse button
		this.collapseBtn = document.createElement('span');
		this.collapseBtn.className = 'collapse-btn';
		this.collapseBtn.textContent = '«';
		this.collapseBtn.title = 'Collapse menu (H)';
		this.container.appendChild(this.collapseBtn);

		// Drag handle
		this.dragHandle = document.createElement("span");
		this.dragHandle.className = 'drag-handle';
		this.dragHandle.innerHTML = '&#9776;';
		this.dragHandle.style.cursor = 'grab';
		this.dragHandle.style.marginRight = '6px';
		this.dragHandle.style.userSelect = 'none';
		this.dragHandle.style.color = '#888';
		this.dragHandle.style.fontSize = '16px';
		this.dragHandle.style.verticalAlign = 'middle';
		this.container.appendChild(this.dragHandle);

		// Drag logic
		var dragOffsetX = 0, dragOffsetY = 0;

		function onDragStart( event )
		{
			event.preventDefault();
			event.stopPropagation();
			var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
			var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
			dragOffsetX = clientX - scope.container.offsetLeft;
			dragOffsetY = clientY - scope.container.offsetTop;
			scope.dragHandle.style.cursor = 'grabbing';
			window.addEventListener('mousemove', onDragMove, false);
			window.addEventListener('mouseup', onDragEnd, false);
			window.addEventListener('touchmove', onDragMove, { passive: false });
			window.addEventListener('touchend', onDragEnd, false);
		}

		function onDragMove( event )
		{
			event.preventDefault();
			var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
			var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
			scope.container.style.left = (clientX - dragOffsetX) + 'px';
			scope.container.style.top = (clientY - dragOffsetY) + 'px';
			scope.isDragged = true;
		}

		function onDragEnd( event )
		{
			scope.dragHandle.style.cursor = 'grab';
			window.removeEventListener('mousemove', onDragMove, false);
			window.removeEventListener('mouseup', onDragEnd, false);
			window.removeEventListener('touchmove', onDragMove, false);
			window.removeEventListener('touchend', onDragEnd, false);
		}

		this.dragHandle.addEventListener('mousedown', onDragStart, false);
		this.dragHandle.addEventListener('touchstart', onDragStart, { passive: false });

		this.foregroundColor = document.createElement("canvas");
		this.foregroundColor.style.marginBottom = '-3px';
		this.foregroundColor.style.cursor = 'pointer';
		this.foregroundColor.width = color_width;
		this.foregroundColor.height = color_height;
		this.container.appendChild(this.foregroundColor);

		this.setForegroundColor( COLOR );

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.backgroundColor = document.createElement("canvas");
		this.backgroundColor.style.marginBottom = '-3px';
		this.backgroundColor.style.cursor = 'pointer';
		this.backgroundColor.width = color_width;
		this.backgroundColor.height = color_height;
		this.container.appendChild(this.backgroundColor);

		this.setBackgroundColor( BACKGROUND_COLOR );

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.selector = document.createElement("select");
		this.selector.className = 'brush-selector';

		for (i = 0; i < BRUSHES.length; i++)
		{
			option = document.createElement("option");
			option.id = i;
			var isNew = NEW_BRUSHES.indexOf( BRUSHES[i] ) !== -1;
			option.textContent = BRUSHES[i].toUpperCase() + ( isNew ? ' (new)' : '' );
			if ( isNew ) option.style.color = 'red';
			this.selector.appendChild(option);
		}

		this.container.appendChild(this.selector);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.opacityLabel = document.createElement("span");
		this.opacityLabel.style.fontSize = '11px';
		this.opacityLabel.innerHTML = '100%';
		this.container.appendChild(this.opacityLabel);

		this.opacitySlider = document.createElement("input");
		this.opacitySlider.type = 'range';
		this.opacitySlider.min = '0';
		this.opacitySlider.max = '100';
		this.opacitySlider.value = '100';
		this.opacitySlider.style.width = '60px';
		this.opacitySlider.style.verticalAlign = 'middle';
		this.opacitySlider.style.margin = '0 4px';
		this.container.appendChild(this.opacitySlider);

		this.opacitySlider.addEventListener('input', function() {
			BRUSH_OPACITY = scope.opacitySlider.value / 100;
			scope.opacityLabel.innerHTML = scope.opacitySlider.value + '%';
		}, false);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.symmetrySelector = document.createElement("select");
		var symOptions = [
			{ label: "Sym: Off", value: "0" },
			{ label: "2", value: "2" },
			{ label: "3", value: "3" },
			{ label: "4", value: "4" },
			{ label: "6", value: "6" },
			{ label: "8", value: "8" }
		];
		for (var s = 0; s < symOptions.length; s++)
		{
			option = document.createElement("option");
			option.value = symOptions[s].value;
			option.innerHTML = symOptions[s].label;
			this.symmetrySelector.appendChild(option);
		}
		this.container.appendChild(this.symmetrySelector);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.save = document.createElement("span"); //getElementById('save');
		this.save.className = 'button';
		this.save.innerHTML = 'Save';
		this.container.appendChild(this.save);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.download = document.createElement("span");
		this.download.className = 'button';
		this.download.innerHTML = 'Download';
		this.container.appendChild(this.download);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.rec = document.createElement("span");
		this.rec.className = 'button';
		this.rec.innerHTML = 'Rec';
		this.container.appendChild(this.rec);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.gif = document.createElement("span");
		this.gif.className = 'button';
		this.gif.innerHTML = 'Gif';
		this.container.appendChild(this.gif);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.upload = document.createElement("span");
		this.upload.className = 'button';
		this.upload.innerHTML = 'Upload';
		this.container.appendChild(this.upload);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.undo = document.createElement("span");
		this.undo.className = 'button';
		this.undo.innerHTML = 'Undo';
		this.container.appendChild(this.undo);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.redo = document.createElement("span");
		this.redo.className = 'button';
		this.redo.innerHTML = 'Redo';
		this.container.appendChild(this.redo);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.clear = document.createElement("Clear");
		this.clear.className = 'button';
		this.clear.innerHTML = 'Clear';
		this.container.appendChild(this.clear);

		separator = document.createElement("span");
		separator.textContent = " | ";
		this.container.appendChild(separator);

		this.zoomIndicator = document.createElement("span");
		this.zoomIndicator.style.padding = '2px 4px';
		this.zoomIndicator.style.fontSize = '11px';
		this.zoomIndicator.innerHTML = '1.0x';
		this.container.appendChild(this.zoomIndicator);

		space = document.createTextNode(" ");
		this.container.appendChild(space);

		this.zoomReset = document.createElement("span");
		this.zoomReset.className = 'button';
		this.zoomReset.innerHTML = 'Reset Zoom';
		this.container.appendChild(this.zoomReset);

		separator = document.createElement("span");
		separator.textContent = " | ";
		this.container.appendChild(separator);

		this.about = document.createElement("About");
		this.about.className = 'button';
		this.about.innerHTML = 'About';
		this.container.appendChild(this.about);
	},

	setForegroundColor: function( color )
	{
		var context = this.foregroundColor.getContext("2d");
		context.fillStyle = 'rgb(' + color[0] + ', ' + color[1] +', ' + color[2] + ')';
		context.fillRect(0, 0, this.foregroundColor.width, this.foregroundColor.height);
		context.fillStyle = 'rgba(0, 0, 0, 0.1)';
		context.fillRect(0, 0, this.foregroundColor.width, 1);
	},

	setBackgroundColor: function( color )
	{
		var context = this.backgroundColor.getContext("2d");
		context.fillStyle = 'rgb(' + color[0] + ', ' + color[1] +', ' + color[2] + ')';
		context.fillRect(0, 0, this.backgroundColor.width, this.backgroundColor.height);
		context.fillStyle = 'rgba(0, 0, 0, 0.1)';
		context.fillRect(0, 0, this.backgroundColor.width, 1);
	},

	setZoomLevel: function( level )
	{
		this.zoomIndicator.innerHTML = level.toFixed(1) + 'x';
	},

	toggleCollapse: function()
	{
		var collapsed = this.container.classList.toggle('collapsed');
		this.collapseBtn.textContent = collapsed ? '≡' : '«';
		this.collapseBtn.title = collapsed ? 'Expand menu (H)' : 'Collapse menu (H)';
		localStorage.setItem('harmonyMenuCollapsed', collapsed ? '1' : '0');
	}
}

// about.js

function About()
{
	this.init();
}

About.prototype =
{
	container: null,

	init: function()
	{
		var text, containerText;

		this.container = document.createElement("div");
		this.container.className = 'gui';
		this.container.style.position = 'absolute';
		this.container.style.top = '0px';
		this.container.style.visibility = 'hidden';
		this.container.style.width = '280px';
		this.container.style.whiteSpace = 'normal';

		containerText = document.createElement("div");
		containerText.style.margin = '10px 10px';
		containerText.style.textAlign = 'left';
		this.container.appendChild(containerText);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<strong>HARMONY</strong> <a href="changelog.txt" target="_blank">r' + REV + '</a> by <a href="http://twitter.com/mrdoob" target="_blank">Mr.doob</a>';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = 'Forked version by <a href="https://github.com/barakbl/harmony" target="_blank"><strong>Barak Bloch</strong></a>';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = 'Brush: <span class="key">d</span><span class="key">f</span> size, <span class="key">r</span> reset<br />Color: <span class="key">shift</span> wheel, <span class="key">alt</span> picker<br />Zoom: <span class="key">ctrl+scroll</span> or pinch, <span class="key">b</span> reset<br />Menu: <span class="key">H</span> collapse / expand';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<strong>Touch gestures</strong><br />2-finger tap — Undo<br />3-finger tap — Redo<br />2-finger pinch — Zoom<br />3-finger swipe down — Collapse menu';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<a href="http://mrdoob.com/blog/post/689" target="_blank">Info</a> - <a href="http://github.com/mrdoob/harmony" target="_blank">Source Code</a>';
		containerText.appendChild(text);

		text = document.createElement("hr");
		containerText.appendChild(text);

		text = document.createElement("p");
		text.innerHTML = '<em>Sketchy</em>, <em>Shaded</em>, <em>Chrome</em>, <em>Fur</em>, <em>LongFur</em> and <em>Web</em> are all variations of the neighbour points connection concept. First implemented in <a href="http://www.zefrank.com/scribbler/" target="_blank">The Scribbler</a>.';
		containerText.appendChild(text);

		text = document.createElement("p");
		text.innerHTML = 'If you like the tool, you can use this button to share your love ;)';
		containerText.appendChild(text);

		text = document.createElement("hr");
		containerText.appendChild(text);

		text = document.createElement("p");
		text.style.textAlign = 'center';
		text.innerHTML = '<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank"><input type="hidden" name="cmd" value="_s-xclick"><input type="hidden" name="hosted_button_id" value="VY7767JMMMYM4"><input type="image" src="https://www.paypal.com/en_GB/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online."><img alt="" border="0" src="https://www.paypal.com/en_GB/i/scr/pixel.gif" width="1" height="1"></form>';
		containerText.appendChild(text);
	},

	show: function()
	{
		this.container.style.visibility = 'visible';
	},

	hide: function()
	{
		this.container.style.visibility = 'hidden';
	}
}

// main.js

const REV = 13;
const BRUSHES = ["sketchy", "shaded", "chrome", "fur", "longfur", "web", "", "simple", "squares", "ribbon", "", "circles", "grid", "eraser", "", "neon", "watercolor", "splatter", "calligraphy", "smoke", "stipple", "lightning", "chalk"];
const NEW_BRUSHES = ["neon", "watercolor", "splatter", "calligraphy", "smoke", "stipple", "lightning", "chalk"];
const USER_AGENT = navigator.userAgent.toLowerCase();

var SCREEN_WIDTH = window.innerWidth,
    SCREEN_HEIGHT = window.innerHeight,
    PIXEL_RATIO = Math.max( 1, window.devicePixelRatio ),
    BRUSH_SIZE = 1,
    BRUSH_PRESSURE = 1,
    BRUSH_OPACITY = 1,
    BRUSH_TILT_X = 0,   // degrees, from PointerEvent.tiltX (-90..90)
    BRUSH_TILT_Y = 0,   // degrees, from PointerEvent.tiltY (-90..90)
    SYMMETRY_AXES = 0,
    symmetryBrushes = [],
    COLOR = [0, 0, 0],
    BACKGROUND_COLOR = [250, 250, 250],
    STORAGE = window.localStorage,
    brush,
    saveTimeOut,
    wacom,
    i,
    mouseX = 0,
    mouseY = 0,
    container,
    foregroundColorSelector,
    backgroundColorSelector,
    menu,
    about,
    canvas,
    flattenCanvas,
    context,
    isFgColorSelectorVisible = false,
    isBgColorSelectorVisible = false,
    isAboutVisible = false,
    isMenuMouseOver = false,
    shiftKeyIsDown = false,
    altKeyIsDown = false,
    isDrawing = false,
    multiTouchFingers = 0,
    undoHistory = [],
    historyIndex = -1,
    HISTORY_MAX = 30,
    zoomLevel = 1,
    panX = 0,
    panY = 0,
    pinchStartDist = 0,
    pinchStartZoom = 1,
    isPinching = false,
    lastPinchCenterX = 0,
    lastPinchCenterY = 0,
    ZOOM_MIN = 1,
    ZOOM_MAX = 50,

    gifFrames = [],
    gifRecCanvas = null,
    gifRecCtx = null,
    gifRecGw = 0,
    gifRecGh = 0,
    gifLastCaptureTime = 0,
    gifCaptureThrottle = 150,
    gifIsRecording = false,
    GIF_MAX_FRAMES = 200;

init();

function screenToCanvas(x, y)
{
	return {
		x: (x - panX) / zoomLevel,
		y: (y - panY) / zoomLevel
	};
}

function applyZoomTransform()
{
	canvas.style.transformOrigin = '0 0';
	canvas.style.transform = 'translate(' + panX + 'px, ' + panY + 'px) scale(' + zoomLevel + ')';
	if (menu) menu.setZoomLevel(zoomLevel);
}

function clampPan()
{
	var maxPanX = 0;
	var maxPanY = 0;
	var minPanX = SCREEN_WIDTH - SCREEN_WIDTH * zoomLevel;
	var minPanY = SCREEN_HEIGHT - SCREEN_HEIGHT * zoomLevel;
	panX = Math.min(maxPanX, Math.max(minPanX, panX));
	panY = Math.min(maxPanY, Math.max(minPanY, panY));
}

function init()
{
	var hash, palette, embed, localStorageImage;

	if (USER_AGENT.search("android") > -1 || USER_AGENT.search("iphone") > -1)
		BRUSH_SIZE = 2;

	if (USER_AGENT.search("safari") > -1 && USER_AGENT.search("chrome") == -1) // Safari
		STORAGE = false;

	document.body.style.backgroundRepeat = 'no-repeat';
	document.body.style.backgroundPosition = 'center center';

	container = document.createElement('div');
	document.body.appendChild(container);

	/*
	 * TODO: In some browsers a naste "Plugin Missing" window appears and people is getting confused.
	 * Disabling it until a better way to handle it appears.
	 *
	 * embed = document.createElement('embed');
	 * embed.id = 'wacom-plugin';
	 * embed.type = 'application/x-wacom-tablet';
	 * document.body.appendChild(embed);
	 *
	 * wacom = document.embeds["wacom-plugin"];
	 */

	canvas = document.createElement("canvas");
	canvas.width = SCREEN_WIDTH * PIXEL_RATIO;
	canvas.height = SCREEN_HEIGHT * PIXEL_RATIO;
	canvas.style.cursor = 'crosshair';
	canvas.style.width = SCREEN_WIDTH + 'px';
	canvas.style.height = SCREEN_HEIGHT + 'px';
	container.appendChild(canvas);

	context = canvas.getContext("2d");
	context.save();
	context.scale(PIXEL_RATIO, PIXEL_RATIO);

	flattenCanvas = document.createElement("canvas");
	flattenCanvas.width = SCREEN_WIDTH * PIXEL_RATIO;
	flattenCanvas.height = SCREEN_HEIGHT * PIXEL_RATIO;

	palette = new Palette();

	foregroundColorSelector = new ColorSelector(palette);
	foregroundColorSelector.addEventListener('change', onForegroundColorSelectorChange, false);
	container.appendChild(foregroundColorSelector.container);

	backgroundColorSelector = new ColorSelector(palette);
	backgroundColorSelector.addEventListener('change', onBackgroundColorSelectorChange, false);
	container.appendChild(backgroundColorSelector.container);

	menu = new Menu();
	menu.foregroundColor.addEventListener('click', onMenuForegroundColor, false);
	menu.foregroundColor.addEventListener('touchend', onMenuForegroundColor, { passive: false });
	menu.backgroundColor.addEventListener('click', onMenuBackgroundColor, false);
	menu.backgroundColor.addEventListener('touchend', onMenuBackgroundColor, false);
	menu.selector.addEventListener('change', onMenuSelectorChange, false);
	menu.symmetrySelector.addEventListener('change', onMenuSymmetryChange, false);
	menu.save.addEventListener('click', onMenuSave, false);
	menu.save.addEventListener('touchend', onMenuSave, false);
	menu.download.addEventListener('click', onMenuDownload, false);
	menu.download.addEventListener('touchend', onMenuDownload, false);
	menu.rec.addEventListener('click', gifToggleRecording, false);
	menu.rec.addEventListener('touchend', gifToggleRecording, false);
	menu.gif.addEventListener('click', onMenuGif, false);
	menu.gif.addEventListener('touchend', onMenuGif, false);
	menu.upload.addEventListener('click', onMenuUpload, false);
	menu.upload.addEventListener('touchend', onMenuUpload, false);
	menu.undo.addEventListener('click', onMenuUndo, false);
	menu.undo.addEventListener('touchend', onMenuUndo, false);
	menu.redo.addEventListener('click', onMenuRedo, false);
	menu.redo.addEventListener('touchend', onMenuRedo, false);
	menu.clear.addEventListener('click', onMenuClear, false);
	menu.clear.addEventListener('touchend', onMenuClear, false);
	menu.about.addEventListener('click', onMenuAbout, false);
	menu.about.addEventListener('touchend', onMenuAbout, false);
	menu.zoomReset.addEventListener('click', onMenuZoomReset, false);
	menu.zoomReset.addEventListener('touchend', onMenuZoomReset, false);
	menu.container.addEventListener('mouseover', onMenuMouseOver, { passive: false });
	menu.container.addEventListener('mouseout', onMenuMouseOut, { passive: false });
	menu.collapseBtn.addEventListener('click', function() { menu.toggleCollapse(); });
	menu.collapseBtn.addEventListener('mousedown', function(e) { e.stopPropagation(); });
	menu.collapseBtn.addEventListener('touchstart', function(e) { e.stopPropagation(); }, { passive: true });
	container.appendChild(menu.container);

	if (localStorage.getItem('harmonyMenuCollapsed') === '1') {
		menu.container.classList.add('collapsed');
		menu.collapseBtn.textContent = '≡';
		menu.collapseBtn.title = 'Expand menu (H)';
	}

	if (STORAGE)
	{
		if (localStorage['harmony-canvas'])
		{
			localStorageImage = new Image();

			localStorageImage.addEventListener("load", function(event)
			{
				localStorageImage.removeEventListener(event.type, arguments.callee, false);
				context.restore();
				context.drawImage(localStorageImage,0,0);
				context.scale(PIXEL_RATIO, PIXEL_RATIO);
				saveToHistory();
			}, false);

			localStorageImage.src = localStorage['harmony-canvas'];
		}

		if (localStorage['harmony-bg'])
		{
			let array = JSON.parse(localStorage['harmony-color']);

			COLOR[0] = array[0];
			COLOR[1] = array[1];
			COLOR[2] = array[2];
		}

		if (localStorage['harmony-bg'])
		{
			let array = JSON.parse(localStorage['harmony-bg']);

			BACKGROUND_COLOR[0] = array[0];
			BACKGROUND_COLOR[1] = array[1];
			BACKGROUND_COLOR[2] = array[2];
		}
	}

	foregroundColorSelector.setColor( COLOR );
	backgroundColorSelector.setColor( BACKGROUND_COLOR );

	if (window.location.hash)
	{
		hash = window.location.hash.substr(1,window.location.hash.length);

		for (i = 0; i < BRUSHES.length; i++)
		{
			if (hash == BRUSHES[i])
			{
				brush = eval("new " + BRUSHES[i] + "(context)");
				menu.selector.selectedIndex = i;
				break;
			}
		}
	}

	if (!brush)
	{
		brush = eval("new " + BRUSHES[0] + "(context)");
	}

	about = new About();
	container.appendChild(about.container);

	window.addEventListener('mousemove', onWindowMouseMove, false);
	window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('keydown', onWindowKeyDown, false);
	window.addEventListener('keyup', onWindowKeyUp, false);
	window.addEventListener('blur', onWindowBlur, false);

	document.addEventListener('pointerdown', onDocumentMouseDown, false);
	document.addEventListener('pointerout', onDocumentMouseOut, false);

	document.addEventListener("dragenter", onDocumentDragEnter, false);
	document.addEventListener("dragover", onDocumentDragOver, false);
	document.addEventListener("drop", onDocumentDrop, false);

	canvas.addEventListener('pointerdown', onCanvasMouseDown, { passive: false });
	canvas.addEventListener('touchstart', onCanvasTouchStart, { passive: false });
	canvas.addEventListener('wheel', onCanvasWheel, { passive: false });

	var _swipeStartY = null;
	var _swipeStartCount = 0;
	document.addEventListener('touchstart', function(e) {
		if (e.touches.length === 3) {
			_swipeStartY = e.touches[0].clientY;
			_swipeStartCount = 3;
		} else {
			_swipeStartY = null;
			_swipeStartCount = 0;
		}
	}, { passive: true });
	document.addEventListener('touchend', function(e) {
		if (_swipeStartCount === 3 && _swipeStartY !== null) {
			var deltaY = e.changedTouches[0].clientY - _swipeStartY;
			if (deltaY > 40) {
				menu.toggleCollapse();
			}
		}
		_swipeStartY = null;
		_swipeStartCount = 0;
	}, { passive: true });

	onWindowResize(null);

	saveToHistory();
}


// SYMMETRY

function getSymmetryPoints(x, y)
{
	if (SYMMETRY_AXES <= 1) return [];
	var cx = SCREEN_WIDTH / 2, cy = SCREEN_HEIGHT / 2;
	var points = [];
	for (var i = 1; i < SYMMETRY_AXES; i++)
	{
		var angle = (i * 2 * Math.PI) / SYMMETRY_AXES;
		var dx = x - cx, dy = y - cy;
		var rx = cx + dx * Math.cos(angle) - dy * Math.sin(angle);
		var ry = cy + dx * Math.sin(angle) + dy * Math.cos(angle);
		points.push({x: rx, y: ry});
	}
	return points;
}

function recreateSymmetryBrushes()
{
	for (var i = 0; i < symmetryBrushes.length; i++)
	{
		symmetryBrushes[i].destroy();
	}
	symmetryBrushes = [];
	if (SYMMETRY_AXES > 1)
	{
		for (var i = 1; i < SYMMETRY_AXES; i++)
		{
			symmetryBrushes.push(eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)"));
		}
	}
}

// WINDOW

function onWindowMouseMove( event )
{
	mouseX = event.clientX;
	mouseY = event.clientY;
}

function onWindowResize()
{
	SCREEN_WIDTH = window.innerWidth;
	SCREEN_HEIGHT = window.innerHeight;

	if (!menu.isDragged)
		menu.container.style.left = ((SCREEN_WIDTH - menu.container.offsetWidth) / 2) + 'px';

	about.container.style.left = ((SCREEN_WIDTH - about.container.offsetWidth) / 2) + 'px';
	about.container.style.top = ((SCREEN_HEIGHT - about.container.offsetHeight) / 2) + 'px';
}

function onWindowKeyDown( event )
{
	if (event.keyCode === 90 && (event.ctrlKey || event.metaKey))
	{
		event.preventDefault();
		if (event.shiftKey)
			onMenuRedo();
		else
			onMenuUndo();
		return;
	}

	if (shiftKeyIsDown)
		return;

	switch(event.keyCode)
	{
		case 16: // Shift
			shiftKeyIsDown = true;
			foregroundColorSelector.container.style.left = mouseX - 125 + 'px';
			foregroundColorSelector.container.style.top = mouseY - 125 + 'px';
			foregroundColorSelector.container.style.visibility = 'visible';
			break;

		case 18: // Alt
			altKeyIsDown = true;
			break;

		case 68: // d
			if(BRUSH_SIZE > 1) BRUSH_SIZE --;
			break;

		case 70: // f
			BRUSH_SIZE ++;
			break;

		case 72: // h
			if (document.activeElement.tagName !== 'INPUT' &&
				document.activeElement.tagName !== 'SELECT') {
				menu.toggleCollapse();
			}
			break;
	}
}

function onWindowKeyUp( event )
{
	switch(event.keyCode)
	{
		case 16: // Shift
			shiftKeyIsDown = false;
			foregroundColorSelector.container.style.visibility = 'hidden';
			break;

		case 18: // Alt
			altKeyIsDown = false;
			break;

		case 82: // r
			brush.destroy();
			brush = eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)");
			recreateSymmetryBrushes();
			break;
		case 66: // b
			document.body.style.backgroundImage = null;
			break;
	}

	context.lineCap = BRUSH_SIZE == 1 ? 'butt' : 'round';
}

function onWindowBlur( event )
{
	shiftKeyIsDown = false;
	altKeyIsDown = false;
}


// DOCUMENT

function onDocumentMouseDown( event )
{
	if (!isMenuMouseOver)
		event.preventDefault();
}

function onDocumentMouseOut( event )
{
	onCanvasMouseUp();
}

function onDocumentDragEnter( event )
{
	event.stopPropagation();
	event.preventDefault();
}

function onDocumentDragOver( event )
{
	event.stopPropagation();
	event.preventDefault();
}

function onDocumentDrop( event )
{
	event.stopPropagation();
	event.preventDefault();

	var file = event.dataTransfer.files[0];

	if (file.type.match(/image.*/))
	{
		/*
		 * TODO: This seems to work on Chromium. But not on Firefox.
		 * Better wait for proper FileAPI?
		 */

		var fileString = event.dataTransfer.getData('text').split("\n");
		document.body.style.backgroundImage = 'url(' + fileString[0] + ')';
	}
}


// COLOR SELECTORS

function onForegroundColorSelectorChange( event )
{
	COLOR = foregroundColorSelector.getColor();

	menu.setForegroundColor( COLOR );

	if (STORAGE)
	{
		localStorage['harmony-color'] = JSON.stringify(COLOR);
	}
}

function onBackgroundColorSelectorChange( event )
{
	BACKGROUND_COLOR = backgroundColorSelector.getColor();

	menu.setBackgroundColor( BACKGROUND_COLOR );

	document.body.style.backgroundColor = 'rgb(' + BACKGROUND_COLOR[0] + ', ' + BACKGROUND_COLOR[1] + ', ' + BACKGROUND_COLOR[2] + ')';

	if (STORAGE)
	{
		localStorage['harmony-bg'] = JSON.stringify(BACKGROUND_COLOR);
	}
}


// MENU

function onMenuForegroundColor()
{
	cleanPopUps();

	foregroundColorSelector.show();
	foregroundColorSelector.container.style.left = ((SCREEN_WIDTH - foregroundColorSelector.container.offsetWidth) / 2) + 'px';
	foregroundColorSelector.container.style.top = ((SCREEN_HEIGHT - foregroundColorSelector.container.offsetHeight) / 2) + 'px';

	isFgColorSelectorVisible = true;
}

function onMenuBackgroundColor()
{
	cleanPopUps();

	backgroundColorSelector.show();
	backgroundColorSelector.container.style.left = ((SCREEN_WIDTH - backgroundColorSelector.container.offsetWidth) / 2) + 'px';
	backgroundColorSelector.container.style.top = ((SCREEN_HEIGHT - backgroundColorSelector.container.offsetHeight) / 2) + 'px';

	isBgColorSelectorVisible = true;
}

function onMenuSelectorChange()
{
	if (BRUSHES[menu.selector.selectedIndex] == "")
		return;

	brush.destroy();
	brush = eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)");
	recreateSymmetryBrushes();

	window.location.hash = BRUSHES[menu.selector.selectedIndex];
}

function onMenuSymmetryChange()
{
	SYMMETRY_AXES = parseInt(menu.symmetrySelector.value, 10);
	recreateSymmetryBrushes();
}

function onMenuMouseOver()
{
	isMenuMouseOver = true;
}

function onMenuMouseOut()
{
	isMenuMouseOver = false;
}

function onMenuSave()
{
	if (STORAGE)
	{
		saveToLocalStorage();
	}
}

function onMenuDownload()
{
	flatten();

	var data = flattenCanvas.toDataURL('image/png');

	var historyData = [];
	var tempCanvas = document.createElement('canvas');
	tempCanvas.width = canvas.width;
	tempCanvas.height = canvas.height;
	var tempCtx = tempCanvas.getContext('2d');

	for (var i = 0; i < undoHistory.length; i++)
	{
		tempCtx.putImageData(undoHistory[i], 0, 0);
		historyData.push(tempCanvas.toDataURL('image/png'));
	}

	var metadata = '<metadata><harmony:history xmlns:harmony="urn:harmony" index="' + historyIndex + '">'
		+ '<![CDATA[' + JSON.stringify(historyData) + ']]>'
		+ '</harmony:history></metadata>';

	var svg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + SCREEN_WIDTH + '" height="' + SCREEN_HEIGHT + '">'
		+ metadata
		+ '<image width="' + SCREEN_WIDTH + '" height="' + SCREEN_HEIGHT + '" xlink:href="' + data + '"/>'
		+ '</svg>';

	var blob = new Blob([svg], { type: 'image/svg+xml' });
	var url = URL.createObjectURL(blob);

	var a = document.createElement('a');
	a.href = url;
	var d = new Date();
	var dateStr = d.getFullYear().toString() +
		(d.getMonth() + 1).toString().padStart(2, '0') +
		d.getDate().toString().padStart(2, '0');
	a.download = 'harmony_' + dateStr + '.svg';
	a.click();

	URL.revokeObjectURL(url);
}

function gifInitRecCanvas()
{
	var w = canvas.width;
	var h = canvas.height;
	var maxW = 800;
	var scale = Math.min(1, maxW / (w / PIXEL_RATIO));
	gifRecGw = Math.round(w * scale / PIXEL_RATIO);
	gifRecGh = Math.round(h * scale / PIXEL_RATIO);
	gifRecCanvas = document.createElement('canvas');
	gifRecCanvas.width = gifRecGw;
	gifRecCanvas.height = gifRecGh;
	gifRecCtx = gifRecCanvas.getContext('2d');
	gifRecCtx.imageSmoothingEnabled = false;
}

function gifRecordFrame()
{
	var now = Date.now();
	var elapsed = gifFrames.length > 0 ? now - gifLastCaptureTime : 0;
	gifRecCtx.fillStyle = 'rgb(' + BACKGROUND_COLOR[0] + ',' + BACKGROUND_COLOR[1] + ',' + BACKGROUND_COLOR[2] + ')';
	gifRecCtx.fillRect(0, 0, gifRecGw, gifRecGh);
	gifRecCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, gifRecGw, gifRecGh);
	gifFrames.push({ dataURL: gifRecCanvas.toDataURL('image/png'), delay: elapsed });
	gifLastCaptureTime = now;

	if (gifFrames.length >= GIF_MAX_FRAMES)
	{
		var thinned = [];
		for (var i = 0; i < gifFrames.length; i += 2)
		{
			var f = gifFrames[i];
			if (i + 1 < gifFrames.length)
				f.delay += gifFrames[i + 1].delay;
			thinned.push(f);
		}
		gifFrames = thinned;
		gifCaptureThrottle = gifCaptureThrottle * 2;
	}
}

function gifMaybeCapture()
{
	if (!gifIsRecording) return;
	var now = Date.now();
	if (now - gifLastCaptureTime >= gifCaptureThrottle)
		gifRecordFrame();
}

function gifToggleRecording(event)
{
	if (event) event.preventDefault();
	gifIsRecording = !gifIsRecording;

	if (gifIsRecording)
	{
		if (!gifRecCanvas) gifInitRecCanvas();
		gifFrames = [];
		gifCaptureThrottle = 150;
		gifLastCaptureTime = 0;
		gifRecordFrame();
		menu.rec.className = 'button rec-active';
	}
	else
	{
		menu.rec.className = 'button';
	}
}

function onMenuGif()
{
	if (gifFrames.length > 0)
	{
		onMenuGifFromRecording();
		return;
	}

	if (undoHistory.length === 0)
	{
		alert('No drawing history to export.');
		return;
	}

	var originalText = menu.gif.innerHTML;
	menu.gif.innerHTML = 'Working...';
	menu.gif.style.pointerEvents = 'none';

	setTimeout(function()
	{
		try
		{
			var w = canvas.width;
			var h = canvas.height;
			var tempCanvas = document.createElement('canvas');
			tempCanvas.width = w;
			tempCanvas.height = h;
			var tempCtx = tempCanvas.getContext('2d');

			var scale = 1;
			if (w > 800 || h > 800)
				scale = Math.min(800 / w, 800 / h);

			var gw = Math.round(w * scale / PIXEL_RATIO);
			var gh = Math.round(h * scale / PIXEL_RATIO);

			var gifCanvas = document.createElement('canvas');
			gifCanvas.width = gw;
			gifCanvas.height = gh;
			var gifCtx = gifCanvas.getContext('2d');

			var frames = [];
			var frameCount = Math.min(undoHistory.length, historyIndex + 1);

			for (var i = 0; i < frameCount; i++)
			{
				gifCtx.fillStyle = 'rgb(' + BACKGROUND_COLOR[0] + ',' + BACKGROUND_COLOR[1] + ',' + BACKGROUND_COLOR[2] + ')';
				gifCtx.fillRect(0, 0, gw, gh);

				tempCtx.putImageData(undoHistory[i], 0, 0);
				gifCtx.drawImage(tempCanvas, 0, 0, w, h, 0, 0, gw, gh);

				frames.push(gifCtx.getImageData(0, 0, gw, gh));
			}

			var delay = Math.max(4, Math.round(300 / frameCount));
			if (delay < 4) delay = 4;
			var delays = [];
			for (var i = 0; i < frames.length; i++)
				delays.push(i === frames.length - 1 ? 200 : delay);
			var gif = encodeGIF(frames, gw, gh, delays);

			var blob = new Blob([gif], { type: 'image/gif' });
			var url = URL.createObjectURL(blob);

			var a = document.createElement('a');
			a.href = url;
			var d = new Date();
			var dateStr = d.getFullYear().toString() +
				(d.getMonth() + 1).toString().padStart(2, '0') +
				d.getDate().toString().padStart(2, '0');
			a.download = 'harmony_' + dateStr + '.gif';
			a.click();

			URL.revokeObjectURL(url);
		}
		catch(e)
		{
			alert('GIF export failed: ' + e.message);
		}

		menu.gif.innerHTML = originalText;
		menu.gif.style.pointerEvents = '';
	}, 50);
}

function onMenuGifFromRecording()
{
	var originalText = menu.gif.innerHTML;
	menu.gif.innerHTML = 'Working...';
	menu.gif.style.pointerEvents = 'none';

	var framesToProcess = gifFrames.slice();
	var delays = [];
	for (var i = 0; i < framesToProcess.length; i++)
		delays.push(i === framesToProcess.length - 1 ? 200 : Math.max(2, Math.round(framesToProcess[i].delay / 10)));

	gifFrames = [];

	var imageDataFrames = [];
	var loaded = 0;
	var tempCanvas = document.createElement('canvas');
	tempCanvas.width = gifRecGw;
	tempCanvas.height = gifRecGh;
	var tempCtx = tempCanvas.getContext('2d');
	tempCtx.imageSmoothingEnabled = false;

	for (var i = 0; i < framesToProcess.length; i++)
	{
		(function(idx) {
			var img = new Image();
			img.onload = function()
			{
				tempCtx.clearRect(0, 0, gifRecGw, gifRecGh);
				tempCtx.drawImage(img, 0, 0);
				imageDataFrames[idx] = tempCtx.getImageData(0, 0, gifRecGw, gifRecGh);
				loaded++;

				if (loaded === framesToProcess.length)
				{
					try
					{
						var gif = encodeGIF(imageDataFrames, gifRecGw, gifRecGh, delays);

						var blob = new Blob([gif], { type: 'image/gif' });
						var url = URL.createObjectURL(blob);

						var a = document.createElement('a');
						a.href = url;
						var d = new Date();
						var dateStr = d.getFullYear().toString() +
							(d.getMonth() + 1).toString().padStart(2, '0') +
							d.getDate().toString().padStart(2, '0');
						a.download = 'harmony_' + dateStr + '.gif';
						a.click();

						URL.revokeObjectURL(url);
					}
					catch(e)
					{
						alert('GIF export failed: ' + e.message);
					}

					menu.gif.innerHTML = originalText;
					menu.gif.style.pointerEvents = '';
				}
			};
			img.src = framesToProcess[idx].dataURL;
		})(i);
	}
}

// Minimal GIF89a encoder with median-cut color quantization

function encodeGIF(frames, width, height, delays)
{
	var buf = [];

	function writeByte(b) { buf.push(b & 0xFF); }
	function writeShort(s) { buf.push(s & 0xFF); buf.push((s >> 8) & 0xFF); }
	function writeBytes(arr) { for (var i = 0; i < arr.length; i++) buf.push(arr[i] & 0xFF); }
	function writeString(s) { for (var i = 0; i < s.length; i++) buf.push(s.charCodeAt(i)); }

	// Quantize: median-cut to 256 colors
	function quantize(imageData)
	{
		var pixels = imageData.data;
		var len = pixels.length / 4;

		// Collect unique-ish colors by sampling
		var sampleStep = Math.max(1, Math.floor(len / 50000));
		var colorList = [];
		for (var i = 0; i < len; i += sampleStep)
		{
			var off = i * 4;
			colorList.push([pixels[off], pixels[off+1], pixels[off+2]]);
		}

		// Median cut
		function medianCut(colors, depth)
		{
			if (depth === 0 || colors.length === 0)
			{
				// Pick the color closest to the centroid to preserve actual pixel colors
				var r = 0, g = 0, b = 0;
				for (var j = 0; j < colors.length; j++)
				{
					r += colors[j][0]; g += colors[j][1]; b += colors[j][2];
				}
				var n = colors.length || 1;
				var cr = r / n, cg = g / n, cb = b / n;
				var bestIdx = 0, bestDist = Infinity;
				for (var j = 0; j < colors.length; j++)
				{
					var dr = colors[j][0] - cr, dg = colors[j][1] - cg, db = colors[j][2] - cb;
					var d = dr*dr + dg*dg + db*db;
					if (d < bestDist) { bestDist = d; bestIdx = j; }
				}
				return [colors[bestIdx] || [Math.round(cr), Math.round(cg), Math.round(cb)]];
			}

			// Find channel with greatest range
			var minR=255,maxR=0,minG=255,maxG=0,minB=255,maxB=0;
			for (var j = 0; j < colors.length; j++)
			{
				if(colors[j][0]<minR) minR=colors[j][0]; if(colors[j][0]>maxR) maxR=colors[j][0];
				if(colors[j][1]<minG) minG=colors[j][1]; if(colors[j][1]>maxG) maxG=colors[j][1];
				if(colors[j][2]<minB) minB=colors[j][2]; if(colors[j][2]>maxB) maxB=colors[j][2];
			}
			var rangeR = maxR-minR, rangeG = maxG-minG, rangeB = maxB-minB;
			var ch = rangeR >= rangeG && rangeR >= rangeB ? 0 : (rangeG >= rangeB ? 1 : 2);

			colors.sort(function(a,b) { return a[ch] - b[ch]; });
			var mid = Math.floor(colors.length / 2);
			return medianCut(colors.slice(0, mid), depth-1)
				.concat(medianCut(colors.slice(mid), depth-1));
		}

		var palette = medianCut(colorList, 8); // 2^8 = 256 max

		// Ensure exactly 256 entries
		while (palette.length < 256)
			palette.push(palette[palette.length - 1] || [0,0,0]);
		palette = palette.slice(0, 256);

		// Build indexed image - find nearest palette color for each pixel
		var indexed = new Uint8Array(len);
		// Build a simple cache for speed
		var cache = {};
		for (var i = 0; i < len; i++)
		{
			var off = i * 4;
			var r = pixels[off], g = pixels[off+1], b = pixels[off+2];
			var key = (r << 16) | (g << 8) | b;
			if (cache[key] !== undefined)
			{
				indexed[i] = cache[key];
			}
			else
			{
				var bestDist = Infinity, bestIdx = 0;
				for (var p = 0; p < 256; p++)
				{
					var dr = r - palette[p][0], dg = g - palette[p][1], db = b - palette[p][2];
					var dist = dr*dr + dg*dg + db*db;
					if (dist < bestDist) { bestDist = dist; bestIdx = p; }
					if (dist === 0) break;
				}
				cache[key] = bestIdx;
				indexed[i] = bestIdx;
			}
		}

		return { palette: palette, indexed: indexed };
	}

	// LZW encoder for GIF
	function lzwEncode(indexed, minCodeSize)
	{
		var clearCode = 1 << minCodeSize;
		var eoiCode = clearCode + 1;
		var codeSize = minCodeSize + 1;
		var nextCode = eoiCode + 1;
		var maxCode = (1 << codeSize);
		var table = {};

		var output = [];
		var curByte = 0;
		var curBit = 0;

		function emit(code)
		{
			curByte |= (code << curBit);
			curBit += codeSize;
			while (curBit >= 8)
			{
				output.push(curByte & 0xFF);
				curByte >>= 8;
				curBit -= 8;
			}
		}

		emit(clearCode);

		// Init table
		for (var i = 0; i < clearCode; i++)
			table[i] = i;

		var prev = indexed[0];
		var tKey;

		for (var i = 1; i < indexed.length; i++)
		{
			var cur = indexed[i];
			tKey = prev + ',' + cur;

			if (table[tKey] !== undefined)
			{
				prev = table[tKey];
			}
			else
			{
				emit(prev);
				if (nextCode < 4096)
				{
					table[tKey] = nextCode++;
					if (nextCode > maxCode && codeSize < 12)
					{
						codeSize++;
						maxCode = 1 << codeSize;
					}
				}
				else
				{
					emit(clearCode);
					table = {};
					for (var j = 0; j < clearCode; j++)
						table[j] = j;
					nextCode = eoiCode + 1;
					codeSize = minCodeSize + 1;
					maxCode = 1 << codeSize;
				}
				prev = cur;
			}
		}

		emit(prev);
		emit(eoiCode);

		if (curBit > 0)
			output.push(curByte & 0xFF);

		return output;
	}

	// Sub-block the LZW data
	function writeSubBlocks(data)
	{
		var idx = 0;
		while (idx < data.length)
		{
			var chunkSize = Math.min(255, data.length - idx);
			writeByte(chunkSize);
			for (var i = 0; i < chunkSize; i++)
				writeByte(data[idx++]);
		}
		writeByte(0); // block terminator
	}

	// --- GIF Header ---
	writeString('GIF89a');
	writeShort(width);
	writeShort(height);

	// Use global color table from first frame
	var firstQ = quantize(frames[0]);
	var globalPalette = firstQ.palette;

	writeByte(0xF7); // GCT flag, 8 bits color resolution, 256 colors (2^(7+1))
	writeByte(0);     // background color index
	writeByte(0);     // pixel aspect ratio

	// Global Color Table
	for (var i = 0; i < 256; i++)
	{
		writeByte(globalPalette[i][0]);
		writeByte(globalPalette[i][1]);
		writeByte(globalPalette[i][2]);
	}

	// Netscape extension for looping
	writeByte(0x21); // Extension
	writeByte(0xFF); // Application Extension
	writeByte(11);   // Block size
	writeString('NETSCAPE2.0');
	writeByte(3);    // Sub-block size
	writeByte(1);    // Loop sub-block ID
	writeShort(0);   // Loop count (0 = infinite)
	writeByte(0);    // Block terminator

	// --- Write each frame ---
	for (var f = 0; f < frames.length; f++)
	{
		var q = (f === 0) ? firstQ : quantize(frames[f]);

		// Graphic Control Extension
		writeByte(0x21); // Extension
		writeByte(0xF9); // Graphic Control
		writeByte(4);    // Block size
		writeByte(0);    // Disposal: none
		writeShort(Array.isArray(delays) ? delays[f] : delays); // Delay in centiseconds
		writeByte(0);    // Transparent color index (not used)
		writeByte(0);    // Block terminator

		// Image Descriptor
		writeByte(0x2C);
		writeShort(0);   // Left
		writeShort(0);   // Top
		writeShort(width);
		writeShort(height);

		if (f === 0)
		{
			writeByte(0); // No local color table, use global
		}
		else
		{
			writeByte(0x87); // Local color table, 256 entries
			for (var i = 0; i < 256; i++)
			{
				writeByte(q.palette[i][0]);
				writeByte(q.palette[i][1]);
				writeByte(q.palette[i][2]);
			}
		}

		// LZW Minimum Code Size
		var minCodeSize = 8;
		writeByte(minCodeSize);

		var lzwData = lzwEncode(q.indexed, minCodeSize);
		writeSubBlocks(lzwData);
	}

	// GIF Trailer
	writeByte(0x3B);

	return new Uint8Array(buf);
}

function onMenuUpload()
{
	var input = document.createElement('input');
	input.type = 'file';
	input.accept = '.svg,image/svg+xml';

	input.addEventListener('change', function()
	{
		var file = input.files[0];

		if (!file)
			return;

		var textReader = new FileReader();

		textReader.addEventListener('load', function()
		{
			var svgText = textReader.result;
			var parser = new DOMParser();
			var doc = parser.parseFromString(svgText, 'image/svg+xml');
			var historyEl = doc.getElementsByTagNameNS('urn:harmony', 'history')[0];
			var savedHistory = null;
			var savedIndex = -1;

			if (historyEl)
			{
				try
				{
					savedHistory = JSON.parse(historyEl.textContent);
					savedIndex = parseInt(historyEl.getAttribute('index'), 10);
				}
				catch(e)
				{
					savedHistory = null;
				}
			}

			var imageEl = doc.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')[0];
			var href = imageEl ? (imageEl.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || imageEl.getAttribute('href')) : null;

			if (!href)
				return;

			var image = new Image();

			image.addEventListener('load', function()
			{
				context.setTransform(1, 0, 0, 1, 0, 0);
				context.clearRect(0, 0, canvas.width, canvas.height);
				context.drawImage(image, 0, 0);
				context.setTransform(PIXEL_RATIO, 0, 0, PIXEL_RATIO, 0, 0);

				saveToLocalStorage();

				if (savedHistory && savedHistory.length > 0)
				{
					var loaded = 0;
					var newHistory = new Array(savedHistory.length);

					for (var i = 0; i < savedHistory.length; i++)
					{
						(function(idx)
						{
							var img = new Image();

							img.addEventListener('load', function()
							{
								var tempCanvas = document.createElement('canvas');
								tempCanvas.width = canvas.width;
								tempCanvas.height = canvas.height;
								var tempCtx = tempCanvas.getContext('2d');
								tempCtx.drawImage(img, 0, 0);
								newHistory[idx] = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

								loaded++;

								if (loaded === savedHistory.length)
								{
									undoHistory = newHistory;
									historyIndex = savedIndex;
								}
							}, false);

							img.src = savedHistory[idx];
						})(i);
					}
				}
				else
				{
					saveToHistory();
				}
			}, false);

			image.src = href;
		}, false);

		textReader.readAsText(file);
	}, false);

	input.click();
}

function onMenuClear()
{
	if (!confirm("Are you sure?"))
		return;

	context.clearRect(0, 0, SCREEN_WIDTH * PIXEL_RATIO, SCREEN_HEIGHT * PIXEL_RATIO);

	saveToLocalStorage();
	saveToHistory();

	brush.destroy();
	brush = eval("new " + BRUSHES[menu.selector.selectedIndex] + "(context)");
	recreateSymmetryBrushes();

	if (gifIsRecording)
	{
		gifFrames = [];
		gifCaptureThrottle = 150;
		gifLastCaptureTime = 0;
		gifRecordFrame();
	}
}

function onMenuAbout()
{
	cleanPopUps();

	isAboutVisible = true;
	about.show();
}


// CANVAS

function onCanvasMouseDown( event )
{
	if ( event.pointerType === 'touch' ) return;

	var data, position;

	clearTimeout(saveTimeOut);
	cleanPopUps();

	if (altKeyIsDown)
	{
		flatten();

		data = flattenCanvas.getContext("2d").getImageData(0, 0, flattenCanvas.width, flattenCanvas.height).data;
		var canvasPos = screenToCanvas(event.clientX, event.clientY);
		position = (Math.round(canvasPos.x) + (Math.round(canvasPos.y) * canvas.width)) * 4;

		foregroundColorSelector.setColor( [ data[position], data[position + 1], data[position + 2] ] );

		return;
	}

	if ( event.pointerType === 'pen' ) {
		BRUSH_PRESSURE = Math.max( 0.05, event.pressure );
		BRUSH_TILT_X   = event.tiltX || 0;
		BRUSH_TILT_Y   = event.tiltY || 0;
	} else {
		BRUSH_PRESSURE = 1;
		BRUSH_TILT_X   = 0;
		BRUSH_TILT_Y   = 0;
	}

	var pos = screenToCanvas(event.clientX, event.clientY);
	isDrawing = true;
	brush.strokeStart( pos.x, pos.y );

	var symPoints = getSymmetryPoints(pos.x, pos.y);
	for (var si = 0; si < symmetryBrushes.length; si++)
	{
		symmetryBrushes[si].strokeStart( symPoints[si].x, symPoints[si].y );
	}

	if (gifIsRecording) gifRecordFrame();

	window.addEventListener('pointermove', onCanvasMouseMove, { passive: false });
	window.addEventListener('pointerup', onCanvasMouseUp, { passive: false });
}

function onCanvasMouseMove( event )
{
	if ( event.pointerType === 'pen' ) {
		BRUSH_PRESSURE = Math.max( 0.05, event.pressure );
		BRUSH_TILT_X   = event.tiltX || 0;
		BRUSH_TILT_Y   = event.tiltY || 0;
	} else {
		BRUSH_PRESSURE = 1;
		BRUSH_TILT_X   = 0;
		BRUSH_TILT_Y   = 0;
	}

	var pos = screenToCanvas(event.clientX, event.clientY);
	brush.stroke( pos.x, pos.y );

	var symPoints = getSymmetryPoints(pos.x, pos.y);
	for (var si = 0; si < symmetryBrushes.length; si++)
	{
		symmetryBrushes[si].stroke( symPoints[si].x, symPoints[si].y );
	}

	gifMaybeCapture();
}

function onCanvasMouseUp()
{
	brush.strokeEnd();

	for (var si = 0; si < symmetryBrushes.length; si++)
	{
		symmetryBrushes[si].strokeEnd();
	}

	window.removeEventListener('pointermove', onCanvasMouseMove, { passive: false });
	window.removeEventListener('pointerup', onCanvasMouseUp, { passive: false });

	if (isDrawing)
	{
		isDrawing = false;
		if (gifIsRecording) gifRecordFrame();
		saveToHistory();
	}

	if (STORAGE)
	{
		clearTimeout(saveTimeOut);
		saveTimeOut = setTimeout(saveToLocalStorage, 2000, true);
	}
}


//

function getTouchDistance(t1, t2)
{
	var dx = t1.pageX - t2.pageX;
	var dy = t1.pageY - t2.pageY;
	return Math.sqrt(dx * dx + dy * dy);
}

function onCanvasTouchStart( event )
{
	cleanPopUps();

	if(event.touches.length == 2)
	{
		event.preventDefault();
		multiTouchFingers = 2;
		isPinching = false;
		pinchStartDist = getTouchDistance(event.touches[0], event.touches[1]);
		pinchStartZoom = zoomLevel;
		lastPinchCenterX = (event.touches[0].pageX + event.touches[1].pageX) / 2;
		lastPinchCenterY = (event.touches[0].pageY + event.touches[1].pageY) / 2;

		if (isDrawing)
		{
			brush.strokeEnd();
			isDrawing = false;
			if (gifIsRecording) gifRecordFrame();
		}

		window.addEventListener('touchmove', onCanvasTouchMove, { passive: false });
		window.addEventListener('touchend', onCanvasTouchEnd, { passive: false });
		return;
	}

	if(event.touches.length == 3)
	{
		event.preventDefault();
		multiTouchFingers = 3;
		return;
	}

	if(event.touches.length == 1)
	{
		event.preventDefault();

		multiTouchFingers = 0;
		isDrawing = true;
		var pos = screenToCanvas(event.touches[0].pageX, event.touches[0].pageY);
		brush.strokeStart( pos.x, pos.y );

		var symPoints = getSymmetryPoints(pos.x, pos.y);
		for (var si = 0; si < symmetryBrushes.length; si++)
		{
			symmetryBrushes[si].strokeStart( symPoints[si].x, symPoints[si].y );
		}

		if (gifIsRecording) gifRecordFrame();

		window.addEventListener('touchmove', onCanvasTouchMove, { passive: false });
		window.addEventListener('touchend', onCanvasTouchEnd, { passive: false });
	}
}

function onCanvasTouchMove( event )
{
	if(event.touches.length == 2)
	{
		event.preventDefault();
		var dist = getTouchDistance(event.touches[0], event.touches[1]);
		var distChange = Math.abs(dist - pinchStartDist);

		if (distChange > 10)
		{
			isPinching = true;
		}

		if (isPinching)
		{
			var centerX = (event.touches[0].pageX + event.touches[1].pageX) / 2;
			var centerY = (event.touches[0].pageY + event.touches[1].pageY) / 2;

			var newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, pinchStartZoom * (dist / pinchStartDist)));

			// Zoom toward pinch center
			panX = centerX - (centerX - panX) * (newZoom / zoomLevel);
			panY = centerY - (centerY - panY) * (newZoom / zoomLevel);
			zoomLevel = newZoom;

			// Also allow panning by moving the pinch center
			panX += centerX - lastPinchCenterX;
			panY += centerY - lastPinchCenterY;

			lastPinchCenterX = centerX;
			lastPinchCenterY = centerY;

			clampPan();
			applyZoomTransform();
		}

		return;
	}

	if(event.touches.length == 1 && isDrawing)
	{
		event.preventDefault();
		var pos = screenToCanvas(event.touches[0].pageX, event.touches[0].pageY);
		brush.stroke( pos.x, pos.y );

		var symPoints = getSymmetryPoints(pos.x, pos.y);
		for (var si = 0; si < symmetryBrushes.length; si++)
		{
			symmetryBrushes[si].stroke( symPoints[si].x, symPoints[si].y );
		}

		gifMaybeCapture();
	}
}

function onCanvasTouchEnd( event )
{
	if(event.touches.length == 0)
	{
		event.preventDefault();

		if (multiTouchFingers == 2 && !isPinching)
		{
			multiTouchFingers = 0;
			onMenuUndo();
			window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
			window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });
			return;
		}

		if (multiTouchFingers == 2 && isPinching)
		{
			multiTouchFingers = 0;
			isPinching = false;
			window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
			window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });
			return;
		}

		if (multiTouchFingers == 3)
		{
			multiTouchFingers = 0;
			onMenuRedo();
			window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
			window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });
			return;
		}

		brush.strokeEnd();

		for (var si = 0; si < symmetryBrushes.length; si++)
		{
			symmetryBrushes[si].strokeEnd();
		}

		window.removeEventListener('touchmove', onCanvasTouchMove, { passive: false });
		window.removeEventListener('touchend', onCanvasTouchEnd, { passive: false });

		isDrawing = false;
		if (gifIsRecording) gifRecordFrame();
		saveToHistory();
	}
}

function onCanvasWheel( event )
{
	if (event.ctrlKey)
	{
		event.preventDefault();

		var delta = -event.deltaY * 0.01;
		var newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, zoomLevel + delta));

		// Zoom toward cursor position
		panX = event.clientX - (event.clientX - panX) * (newZoom / zoomLevel);
		panY = event.clientY - (event.clientY - panY) * (newZoom / zoomLevel);
		zoomLevel = newZoom;

		clampPan();
		applyZoomTransform();
	}
}

function onMenuZoomReset()
{
	zoomLevel = 1;
	panX = 0;
	panY = 0;
	applyZoomTransform();
}

//

function saveToHistory()
{
	undoHistory = undoHistory.slice(0, historyIndex + 1);
	undoHistory.push(context.getImageData(0, 0, canvas.width, canvas.height));

	if (undoHistory.length > HISTORY_MAX)
		undoHistory.splice(0, undoHistory.length - HISTORY_MAX);

	historyIndex = undoHistory.length - 1;
}

function onMenuUndo()
{
	if (historyIndex <= 0)
		return;

	historyIndex--;
	context.putImageData(undoHistory[historyIndex], 0, 0);
	saveToLocalStorage();
	if (gifIsRecording) gifRecordFrame();
}

function onMenuRedo()
{
	if (historyIndex >= undoHistory.length - 1)
		return;

	historyIndex++;
	context.putImageData(undoHistory[historyIndex], 0, 0);
	saveToLocalStorage();
	if (gifIsRecording) gifRecordFrame();
}

function saveToLocalStorage()
{
	localStorage['harmony-canvas'] = canvas.toDataURL('image/png');
}

function flatten()
{
	var context = flattenCanvas.getContext("2d");

	context.fillStyle = 'rgb(' + BACKGROUND_COLOR[0] + ', ' + BACKGROUND_COLOR[1] + ', ' + BACKGROUND_COLOR[2] + ')';
	context.fillRect(0, 0, canvas.width, canvas.height);
	context.drawImage(canvas, 0, 0);
}

function cleanPopUps()
{
	if (isFgColorSelectorVisible)
	{
		foregroundColorSelector.hide();
		isFgColorSelectorVisible = false;
	}

	if (isBgColorSelectorVisible)
	{
		backgroundColorSelector.hide();
		isBgColorSelectorVisible = false;
	}

	if (isAboutVisible)
	{
		about.hide();
		isAboutVisible = false;
	}
}

		</script>
	</body>
</html>
